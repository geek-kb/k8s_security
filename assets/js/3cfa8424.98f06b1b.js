"use strict";(globalThis.webpackChunkk_8_s_security=globalThis.webpackChunkk_8_s_security||[]).push([[4536],{8453(e,i,n){n.d(i,{R:()=>c,x:()=>a});var t=n(6540);const s={},r=t.createContext(s);function c(e){const i=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),t.createElement(r.Provider,{value:i},e.children)}},8642(e,i,n){n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"best_practices/cluster_setup_and_hardening/network_security/service_mesh_security","title":"Service Mesh Security","description":"Improve Kubernetes security by implementing mutual TLS (mTLS), zero-trust networking, and policy-based access control using service meshes like Istio, Linkerd, and Cilium.","source":"@site/docs/best_practices/cluster_setup_and_hardening/network_security/service_mesh_security.md","sourceDirName":"best_practices/cluster_setup_and_hardening/network_security","slug":"/best_practices/cluster_setup_and_hardening/network_security/service_mesh_security","permalink":"/docs/best_practices/cluster_setup_and_hardening/network_security/service_mesh_security","draft":false,"unlisted":false,"editUrl":"https://github.com/geek-kb/k8s_security/edit/main/docs/best_practices/cluster_setup_and_hardening/network_security/service_mesh_security.md","tags":[{"inline":true,"label":"best-practice","permalink":"/docs/tags/best-practice"},{"inline":true,"label":"network","permalink":"/docs/tags/network"},{"inline":true,"label":"service-mesh","permalink":"/docs/tags/service-mesh"},{"inline":true,"label":"mTLS","permalink":"/docs/tags/m-tls"},{"inline":true,"label":"CKS","permalink":"/docs/tags/cks"}],"version":"current","lastUpdatedBy":"Itai Ganot","lastUpdatedAt":1770102262000,"sidebarPosition":8,"frontMatter":{"title":"Service Mesh Security","description":"Improve Kubernetes security by implementing mutual TLS (mTLS), zero-trust networking, and policy-based access control using service meshes like Istio, Linkerd, and Cilium.","sidebar_position":8,"keywords":["kubernetes security best practices","service mesh","mTLS","mutual TLS","zero trust networking","istio","linkerd","cilium service mesh","service mesh security","policy-based access control","sidecar proxy","envoy proxy","service-to-service encryption","CKS"],"tags":["best-practice","network","service-mesh","mTLS","CKS"],"related":["/docs/best_practices/cluster_setup_and_hardening/network_security/network_policies/","/docs/best_practices/cluster_setup_and_hardening/network_security/cilium/","/docs/attack_vectors/traffic_hijacking/"]},"sidebar":"default","previous":{"title":"Network Policies","permalink":"/docs/best_practices/cluster_setup_and_hardening/network_security/network_policies"},"next":{"title":"Securing Kubernetes Network Traffic","permalink":"/docs/best_practices/cluster_setup_and_hardening/network_security/traffic_hijacking_mitigation"}}');var s=n(4848),r=n(8453);const c={title:"Service Mesh Security",description:"Improve Kubernetes security by implementing mutual TLS (mTLS), zero-trust networking, and policy-based access control using service meshes like Istio, Linkerd, and Cilium.",sidebar_position:8,keywords:["kubernetes security best practices","service mesh","mTLS","mutual TLS","zero trust networking","istio","linkerd","cilium service mesh","service mesh security","policy-based access control","sidecar proxy","envoy proxy","service-to-service encryption","CKS"],tags:["best-practice","network","service-mesh","mTLS","CKS"],related:["/docs/best_practices/cluster_setup_and_hardening/network_security/network_policies/","/docs/best_practices/cluster_setup_and_hardening/network_security/cilium/","/docs/attack_vectors/traffic_hijacking/"]},a="Service Mesh Security",o={},l=[{value:"1. Mutual TLS (mTLS)",id:"1-mutual-tls-mtls",level:2},{value:"Istio mTLS Configuration",id:"istio-mtls-configuration",level:3},{value:"Linkerd mTLS",id:"linkerd-mtls",level:3},{value:"2. Zero-Trust Authorization Policies",id:"2-zero-trust-authorization-policies",level:2},{value:"Istio Authorization Policies",id:"istio-authorization-policies",level:3},{value:"JWT-Based Authorization",id:"jwt-based-authorization",level:3},{value:"3. Traffic Policies and Rate Limiting",id:"3-traffic-policies-and-rate-limiting",level:2},{value:"Circuit Breaking",id:"circuit-breaking",level:3},{value:"Rate Limiting",id:"rate-limiting",level:3},{value:"4. Observability and Auditing",id:"4-observability-and-auditing",level:2},{value:"Enable Access Logging in Istio",id:"enable-access-logging-in-istio",level:3},{value:"Security-Relevant Metrics",id:"security-relevant-metrics",level:3},{value:"5. Service Mesh Selection",id:"5-service-mesh-selection",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"References",id:"references",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"service-mesh-security",children:"Service Mesh Security"})}),"\n",(0,s.jsxs)(i.p,{children:["A ",(0,s.jsx)(i.strong,{children:"service mesh"})," provides a dedicated infrastructure layer for handling ",(0,s.jsx)(i.strong,{children:"secure service-to-service communication"})," within a Kubernetes cluster. By abstracting networking logic away from application code, service meshes enable consistent security policies, observability, and traffic management across all microservices."]}),"\n",(0,s.jsxs)(i.p,{children:["Popular service mesh implementations include ",(0,s.jsx)(i.strong,{children:"Istio"}),", ",(0,s.jsx)(i.strong,{children:"Linkerd"}),", ",(0,s.jsx)(i.strong,{children:"Cilium Service Mesh"}),", and ",(0,s.jsx)(i.strong,{children:"Consul Connect"}),". Each provides capabilities for ",(0,s.jsx)(i.strong,{children:"mutual TLS (mTLS)"}),", ",(0,s.jsx)(i.strong,{children:"traffic encryption"}),", ",(0,s.jsx)(i.strong,{children:"authorization policies"}),", and ",(0,s.jsx)(i.strong,{children:"observability"}),"."]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"1-mutual-tls-mtls",children:"1. Mutual TLS (mTLS)"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Required knowledge for the CKS certification."})}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Issue:"})," By default, pods communicate over the cluster network using unencrypted traffic. Attackers with network access can eavesdrop on service-to-service communication and perform man-in-the-middle attacks.",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(i.strong,{children:"Fix:"})," Enable mutual TLS (mTLS) to encrypt all traffic and authenticate both client and server using X.509 certificates."]}),"\n",(0,s.jsxs)(i.p,{children:["mTLS ensures that ",(0,s.jsx)(i.strong,{children:"both the client and server authenticate each other"})," using certificates, and all traffic between them is encrypted. Service meshes automate certificate issuance and rotation."]}),"\n",(0,s.jsx)(i.h3,{id:"istio-mtls-configuration",children:"Istio mTLS Configuration"}),"\n",(0,s.jsx)(i.p,{children:"Enable strict mTLS cluster-wide:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",children:"apiVersion: security.istio.io/v1\nkind: PeerAuthentication\nmetadata:\n  name: default\n  namespace: istio-system\nspec:\n  mtls:\n    mode: STRICT\n"})}),"\n",(0,s.jsx)(i.p,{children:"Enable mTLS for a specific namespace:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",children:"apiVersion: security.istio.io/v1\nkind: PeerAuthentication\nmetadata:\n  name: default\n  namespace: production\nspec:\n  mtls:\n    mode: STRICT\n"})}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"mTLS Modes:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"STRICT"}),": Only accept mTLS traffic (recommended for production)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"PERMISSIVE"}),": Accept both plaintext and mTLS traffic (useful during migration)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"DISABLE"}),": Disable mTLS (not recommended)"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"linkerd-mtls",children:"Linkerd mTLS"}),"\n",(0,s.jsx)(i.p,{children:"Linkerd enables mTLS by default for all meshed workloads. Verify mTLS status:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:"linkerd viz edges deployment -n production\n"})}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"2-zero-trust-authorization-policies",children:"2. Zero-Trust Authorization Policies"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Issue:"})," Without authorization policies, any service can communicate with any other service in the cluster, enabling lateral movement after compromise.",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(i.strong,{children:"Fix:"})," Implement deny-by-default authorization policies and explicitly allow only required service-to-service communication."]}),"\n",(0,s.jsx)(i.h3,{id:"istio-authorization-policies",children:"Istio Authorization Policies"}),"\n",(0,s.jsx)(i.p,{children:"Deny all traffic by default:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",children:"apiVersion: security.istio.io/v1\nkind: AuthorizationPolicy\nmetadata:\n  name: deny-all\n  namespace: production\nspec:\n  {}\n"})}),"\n",(0,s.jsx)(i.p,{children:"Allow specific service communication:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",children:'apiVersion: security.istio.io/v1\nkind: AuthorizationPolicy\nmetadata:\n  name: allow-frontend-to-api\n  namespace: production\nspec:\n  selector:\n    matchLabels:\n      app: api-server\n  action: ALLOW\n  rules:\n    - from:\n        - source:\n            principals: ["cluster.local/ns/production/sa/frontend"]\n      to:\n        - operation:\n            methods: ["GET", "POST"]\n            paths: ["/api/*"]\n'})}),"\n",(0,s.jsx)(i.h3,{id:"jwt-based-authorization",children:"JWT-Based Authorization"}),"\n",(0,s.jsx)(i.p,{children:"Allow traffic only from services with a valid JWT:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",children:'apiVersion: security.istio.io/v1\nkind: AuthorizationPolicy\nmetadata:\n  name: require-jwt\n  namespace: production\nspec:\n  selector:\n    matchLabels:\n      app: secure-api\n  action: ALLOW\n  rules:\n    - from:\n        - source:\n            requestPrincipals: ["https://auth.example.com/*"]\n'})}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"3-traffic-policies-and-rate-limiting",children:"3. Traffic Policies and Rate Limiting"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Issue:"})," Services without traffic controls are vulnerable to cascading failures and denial-of-service attacks.",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(i.strong,{children:"Fix:"})," Implement circuit breaking and rate limiting to protect services from overload and abuse."]}),"\n",(0,s.jsx)(i.h3,{id:"circuit-breaking",children:"Circuit Breaking"}),"\n",(0,s.jsx)(i.p,{children:"Prevent cascading failures by limiting connections to unhealthy services:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",children:"apiVersion: networking.istio.io/v1beta1\nkind: DestinationRule\nmetadata:\n  name: api-circuit-breaker\nspec:\n  host: api-server\n  trafficPolicy:\n    connectionPool:\n      tcp:\n        maxConnections: 100\n      http:\n        http1MaxPendingRequests: 100\n        http2MaxRequests: 1000\n    outlierDetection:\n      consecutive5xxErrors: 5\n      interval: 30s\n      baseEjectionTime: 60s\n      maxEjectionPercent: 50\n"})}),"\n",(0,s.jsx)(i.h3,{id:"rate-limiting",children:"Rate Limiting"}),"\n",(0,s.jsx)(i.p,{children:"Protect services from request floods:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",children:'apiVersion: networking.istio.io/v1alpha3\nkind: EnvoyFilter\nmetadata:\n  name: rate-limit\n  namespace: production\nspec:\n  workloadSelector:\n    labels:\n      app: api-server\n  configPatches:\n    - applyTo: HTTP_FILTER\n      match:\n        context: SIDECAR_INBOUND\n      patch:\n        operation: INSERT_BEFORE\n        value:\n          name: envoy.filters.http.local_ratelimit\n          typed_config:\n            "@type": type.googleapis.com/udpa.type.v1.TypedStruct\n            type_url: type.googleapis.com/envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit\n            value:\n              stat_prefix: http_local_rate_limiter\n              token_bucket:\n                max_tokens: 100\n                tokens_per_fill: 100\n                fill_interval: 60s\n'})}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"4-observability-and-auditing",children:"4. Observability and Auditing"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Issue:"})," Without visibility into service-to-service traffic, security incidents and policy violations go undetected.",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(i.strong,{children:"Fix:"})," Enable access logging, distributed tracing, and metrics collection for security monitoring."]}),"\n",(0,s.jsx)(i.h3,{id:"enable-access-logging-in-istio",children:"Enable Access Logging in Istio"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",children:"apiVersion: telemetry.istio.io/v1alpha1\nkind: Telemetry\nmetadata:\n  name: access-logging\n  namespace: istio-system\nspec:\n  accessLogging:\n    - providers:\n        - name: envoy\n      filter:\n        expression: response.code >= 400\n"})}),"\n",(0,s.jsx)(i.h3,{id:"security-relevant-metrics",children:"Security-Relevant Metrics"}),"\n",(0,s.jsx)(i.p,{children:"Monitor these metrics for security anomalies:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"istio_requests_total"})," with ",(0,s.jsx)(i.code,{children:"response_code=403"})," (authorization failures)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"istio_tcp_connections_closed_total"})," with ",(0,s.jsx)(i.code,{children:"connection_security_policy=unknown"})," (non-mTLS connections)"]}),"\n",(0,s.jsx)(i.li,{children:"Unusual traffic patterns between services"}),"\n"]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"5-service-mesh-selection",children:"5. Service Mesh Selection"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Issue:"})," Different service meshes have different security features, performance overhead, and complexity.",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(i.strong,{children:"Fix:"})," Select a service mesh based on your security requirements and operational capacity."]}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Feature"}),(0,s.jsx)(i.th,{children:"Istio"}),(0,s.jsx)(i.th,{children:"Linkerd"}),(0,s.jsx)(i.th,{children:"Cilium"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"mTLS"}),(0,s.jsx)(i.td,{children:"Configurable"}),(0,s.jsx)(i.td,{children:"Default"}),(0,s.jsx)(i.td,{children:"WireGuard/IPsec"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Authorization Policies"}),(0,s.jsx)(i.td,{children:"Powerful"}),(0,s.jsx)(i.td,{children:"Basic"}),(0,s.jsx)(i.td,{children:"eBPF-based"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Sidecar Model"}),(0,s.jsx)(i.td,{children:"Envoy proxy"}),(0,s.jsx)(i.td,{children:"Lightweight proxy"}),(0,s.jsx)(i.td,{children:"eBPF (sidecar-free)"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Performance Overhead"}),(0,s.jsx)(i.td,{children:"Higher"}),(0,s.jsx)(i.td,{children:"Lower"}),(0,s.jsx)(i.td,{children:"Lowest"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Complexity"}),(0,s.jsx)(i.td,{children:"High"}),(0,s.jsx)(i.td,{children:"Low"}),(0,s.jsx)(i.td,{children:"Medium"})]})]})]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(i.p,{children:["Service meshes provide a powerful security layer for Kubernetes by enforcing ",(0,s.jsx)(i.strong,{children:"encryption"}),", ",(0,s.jsx)(i.strong,{children:"identity-based authentication"}),", ",(0,s.jsx)(i.strong,{children:"fine-grained authorization"}),", and ",(0,s.jsx)(i.strong,{children:"comprehensive observability"}),"."]}),"\n",(0,s.jsx)(i.p,{children:"Key takeaways:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Enable ",(0,s.jsx)(i.strong,{children:"strict mTLS"})," for all production workloads"]}),"\n",(0,s.jsxs)(i.li,{children:["Implement ",(0,s.jsx)(i.strong,{children:"deny-by-default"})," authorization policies"]}),"\n",(0,s.jsxs)(i.li,{children:["Use ",(0,s.jsx)(i.strong,{children:"service identities"})," (ServiceAccounts) for authorization"]}),"\n",(0,s.jsxs)(i.li,{children:["Enable ",(0,s.jsx)(i.strong,{children:"access logging"})," for security auditing"]}),"\n",(0,s.jsxs)(i.li,{children:["Monitor ",(0,s.jsx)(i.strong,{children:"mTLS coverage"})," and ",(0,s.jsx)(i.strong,{children:"authorization failures"})]}),"\n"]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"references",children:"References"}),"\n",(0,s.jsx)(i.p,{children:"This article is based on information from the following official sources:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"https://istio.io/latest/docs/reference/config/security/peer_authentication/",children:"PeerAuthentication"})," - Istio Documentation"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"https://istio.io/latest/docs/reference/config/security/authorization-policy/",children:"Authorization Policy"})," - Istio Documentation"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"https://linkerd.io/2/features/automatic-mtls/",children:"Automatic mTLS"})," - Linkerd Documentation"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"https://docs.cilium.io/en/stable/network/servicemesh/",children:"Cilium Service Mesh"})," - Cilium Documentation"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);