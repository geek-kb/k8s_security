"use strict";(globalThis.webpackChunkk_8_s_security=globalThis.webpackChunkk_8_s_security||[]).push([[1052],{2475(e,n,s){s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"best-practices/cluster-setup-and-hardening/rbac-and-identity/exec-attach-security","title":"Securing Exec and Attach Access","description":"Best practices for restricting kubectl exec and attach permissions to prevent credential theft and unauthorized container access.","source":"@site/docs/best-practices/cluster-setup-and-hardening/rbac-and-identity/exec-attach-security.md","sourceDirName":"best-practices/cluster-setup-and-hardening/rbac-and-identity","slug":"/best-practices/cluster-setup-and-hardening/rbac-and-identity/exec-attach-security","permalink":"/kubernetes-security/best-practices/cluster-setup-and-hardening/rbac-and-identity/exec-attach-security","draft":false,"unlisted":false,"editUrl":"https://github.com/geek-kb/k8s_security/edit/main/docs/best-practices/cluster-setup-and-hardening/rbac-and-identity/exec-attach-security.md","tags":[],"version":"current","lastUpdatedBy":"Itai Ganot","lastUpdatedAt":1771236448000,"sidebarPosition":12,"frontMatter":{"title":"Securing Exec and Attach Access","sidebar_position":12,"description":"Best practices for restricting kubectl exec and attach permissions to prevent credential theft and unauthorized container access.","keywords":["kubernetes security best practices","kubectl exec security","RBAC restrictions","admission control","audit logging","ephemeral containers","distroless images","debug containers","pod security","container access control"]},"sidebar":"default","previous":{"title":"Kubernetes Service Account Token Security: Expiration, Lifetime & Best Practices","permalink":"/kubernetes-security/best-practices/cluster-setup-and-hardening/rbac-and-identity/service-account-token-security"},"next":{"title":"Securing Debug Container Access","permalink":"/kubernetes-security/best-practices/cluster-setup-and-hardening/rbac-and-identity/debug-container-security"}}');var t=s(4848),a=s(8453);const r={title:"Securing Exec and Attach Access",sidebar_position:12,description:"Best practices for restricting kubectl exec and attach permissions to prevent credential theft and unauthorized container access.",keywords:["kubernetes security best practices","kubectl exec security","RBAC restrictions","admission control","audit logging","ephemeral containers","distroless images","debug containers","pod security","container access control"]},c="Securing Exec and Attach Access",o={},l=[{value:"1. Restrict RBAC Permissions for Exec and Attach",id:"1-restrict-rbac-permissions-for-exec-and-attach",level:2},{value:"Deny Exec and Attach by Default",id:"deny-exec-and-attach-by-default",level:3},{value:"Grant Exec Access to Specific Pods Only",id:"grant-exec-access-to-specific-pods-only",level:3},{value:"Audit Who Has Exec/Attach Access",id:"audit-who-has-execattach-access",level:3},{value:"2. Implement Admission Control for Exec Operations",id:"2-implement-admission-control-for-exec-operations",level:2},{value:"Create Validating Webhook for Exec",id:"create-validating-webhook-for-exec",level:3},{value:"Example Webhook Logic",id:"example-webhook-logic",level:3},{value:"3. Enable Comprehensive Audit Logging",id:"3-enable-comprehensive-audit-logging",level:2},{value:"Configure Audit Policy for Exec/Attach",id:"configure-audit-policy-for-execattach",level:3},{value:"Query Audit Logs for Exec Activity",id:"query-audit-logs-for-exec-activity",level:3},{value:"4. Use Ephemeral Debug Containers Instead",id:"4-use-ephemeral-debug-containers-instead",level:2},{value:"Create Ephemeral Debug Container",id:"create-ephemeral-debug-container",level:3},{value:"Grant Debug Permissions Instead of Exec",id:"grant-debug-permissions-instead-of-exec",level:3},{value:"5. Remove Shells and Debugging Tools from Production Images",id:"5-remove-shells-and-debugging-tools-from-production-images",level:2},{value:"Use Distroless Base Images",id:"use-distroless-base-images",level:3},{value:"Verify No Shell in Container",id:"verify-no-shell-in-container",level:3},{value:"Build Multi-Stage Images",id:"build-multi-stage-images",level:3},{value:"6. Implement Network Segmentation",id:"6-implement-network-segmentation",level:2},{value:"Deny Egress to Internal Services",id:"deny-egress-to-internal-services",level:3},{value:"7. Monitor and Alert on Exec Usage",id:"7-monitor-and-alert-on-exec-usage",level:2},{value:"Create Falco Rules for Exec Detection",id:"create-falco-rules-for-exec-detection",level:3},{value:"Create Prometheus Alerts",id:"create-prometheus-alerts",level:3},{value:"Query Metrics",id:"query-metrics",level:3},{value:"8. Use Pod Security Standards",id:"8-use-pod-security-standards",level:2},{value:"Apply Restricted Profile",id:"apply-restricted-profile",level:3},{value:"Deny Privileged Containers",id:"deny-privileged-containers",level:3},{value:"9. Implement Break-Glass Procedures",id:"9-implement-break-glass-procedures",level:2},{value:"Create Just-in-Time Access Request",id:"create-just-in-time-access-request",level:3},{value:"Automated Expiration Script",id:"automated-expiration-script",level:3},{value:"Security Checklist",id:"security-checklist",level:2},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"securing-exec-and-attach-access",children:"Securing Exec and Attach Access"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Required knowledge for the CKS certification."})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"pods/exec"})," and ",(0,t.jsx)(n.code,{children:"pods/attach"})," subresources provide powerful debugging capabilities but also represent significant security risks. Unrestricted access allows attackers to execute arbitrary commands inside containers, steal credentials, and pivot to connected systems."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," By default, many RBAC roles grant broad exec and attach permissions, allowing users to access any container in authorized namespaces and extract sensitive data.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Apply strict RBAC controls, implement admission policies, enable audit logging, and use alternative debugging methods that don't require exec access."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"1-restrict-rbac-permissions-for-exec-and-attach",children:"1. Restrict RBAC Permissions for Exec and Attach"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Overly permissive roles grant exec and attach access to all pods, enabling credential theft from any container.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Grant exec/attach permissions only when necessary and restrict to specific pods or namespaces."]}),"\n",(0,t.jsx)(n.h3,{id:"deny-exec-and-attach-by-default",children:"Deny Exec and Attach by Default"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: developer-readonly\n  namespace: production\nrules:\n  - apiGroups: [""]\n    resources: ["pods", "pods/log"]\n    verbs: ["get", "list", "watch"]\n  - apiGroups: ["apps"]\n    resources: ["deployments", "replicasets"]\n    verbs: ["get", "list"]\n  # Explicitly exclude pods/exec and pods/attach\n'})}),"\n",(0,t.jsx)(n.h3,{id:"grant-exec-access-to-specific-pods-only",children:"Grant Exec Access to Specific Pods Only"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: debug-specific-app\n  namespace: production\nrules:\n  - apiGroups: [""]\n    resources: ["pods/exec"]\n    verbs: ["create"]\n    resourceNames:\n      - "debug-pod-12345"\n      - "troubleshooting-pod-67890"\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: debug-binding\n  namespace: production\nsubjects:\n  - kind: User\n    name: operator@company.com\n    apiGroup: rbac.authorization.k8s.io\nroleRef:\n  kind: Role\n  name: debug-specific-app\n  apiGroup: rbac.authorization.k8s.io\n'})}),"\n",(0,t.jsx)(n.h3,{id:"audit-who-has-execattach-access",children:"Audit Who Has Exec/Attach Access"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Find all roles granting exec access\nkubectl get roles,clusterroles -A -o json | \\\n  jq '.items[] | select(.rules[]? | select(.resources[]? | contains(\"exec\")))'\n\n# Find all role bindings with exec permissions\nkubectl get rolebindings,clusterrolebindings -A -o json | \\\n  jq '.items[] | select(.roleRef.name as $role |\n    [kubectl get role/$role -o json | select(.rules[]? |\n    select(.resources[]? | contains(\"exec\")))] | length > 0)'\n\n# Check specific user's exec permissions\nkubectl auth can-i create pods/exec -n production --as user@company.com\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"2-implement-admission-control-for-exec-operations",children:"2. Implement Admission Control for Exec Operations"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Even with RBAC restrictions, there's no real-time visibility or blocking of suspicious exec commands.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Use admission webhooks to log, audit, and optionally block exec/attach operations."]}),"\n",(0,t.jsx)(n.h3,{id:"create-validating-webhook-for-exec",children:"Create Validating Webhook for Exec"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: admissionregistration.k8s.io/v1\nkind: ValidatingWebhookConfiguration\nmetadata:\n  name: validate-exec\nwebhooks:\n  - name: exec-validator.company.com\n    admissionReviewVersions: ["v1"]\n    clientConfig:\n      service:\n        name: exec-validator\n        namespace: security\n        path: "/validate"\n      caBundle: LS0tLS1CRUdJTi...\n    rules:\n      - operations: ["CONNECT"]\n        apiGroups: [""]\n        apiVersions: ["v1"]\n        resources: ["pods/exec", "pods/attach"]\n    failurePolicy: Fail\n    sideEffects: None\n    timeoutSeconds: 5\n'})}),"\n",(0,t.jsx)(n.h3,{id:"example-webhook-logic",children:"Example Webhook Logic"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'// Deny exec to pods with sensitive labels\nfunc validateExec(ar *admissionv1.AdmissionReview) *admissionv1.AdmissionResponse {\n    pod := getPod(ar.Request.Namespace, ar.Request.Name)\n\n    if pod.Labels["env"] == "production" &&\n       pod.Labels["sensitive"] == "true" {\n        return &admissionv1.AdmissionResponse{\n            Allowed: false,\n            Result: &metav1.Status{\n                Message: "Exec not allowed on sensitive production pods",\n            },\n        }\n    }\n\n    return &admissionv1.AdmissionResponse{Allowed: true}\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"3-enable-comprehensive-audit-logging",children:"3. Enable Comprehensive Audit Logging"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Exec and attach operations leave no trace without audit logging, making forensics impossible.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Enable detailed audit logging for all exec/attach operations."]}),"\n",(0,t.jsx)(n.h3,{id:"configure-audit-policy-for-execattach",children:"Configure Audit Policy for Exec/Attach"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: audit.k8s.io/v1\nkind: Policy\nrules:\n  # Log all exec and attach operations with full request/response\n  - level: RequestResponse\n    verbs: ["create"]\n    resources:\n      - group: ""\n        resources: ["pods/exec", "pods/attach"]\n    omitStages:\n      - RequestReceived\n\n  # Log portforward as well\n  - level: RequestResponse\n    verbs: ["create"]\n    resources:\n      - group: ""\n        resources: ["pods/portforward"]\n'})}),"\n",(0,t.jsx)(n.h3,{id:"query-audit-logs-for-exec-activity",children:"Query Audit Logs for Exec Activity"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'# Search for all exec operations\nkubectl logs -n kube-system kube-apiserver-master | \\\n  grep -E "pods/exec.*CONNECT" | \\\n  jq \'.user.username, .objectRef.namespace, .objectRef.name, .requestURI\'\n\n# Find exec operations by specific user\nkubectl logs -n kube-system kube-apiserver-master | \\\n  jq \'select(.objectRef.resource == "pods" and\n              .objectRef.subresource == "exec" and\n              .user.username == "suspicious@company.com")\'\n\n# Check what commands were executed (if container logging enabled)\nkubectl logs -n kube-system kube-apiserver-master | \\\n  jq \'select(.objectRef.subresource == "exec") | .requestURI\'\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"4-use-ephemeral-debug-containers-instead",children:"4. Use Ephemeral Debug Containers Instead"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Traditional exec requires containers to have shells and debugging tools, increasing attack surface.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Use Kubernetes ephemeral debug containers that don't require modifying existing pods."]}),"\n",(0,t.jsx)(n.h3,{id:"create-ephemeral-debug-container",children:"Create Ephemeral Debug Container"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Debug a pod without exec\nkubectl debug -it webapp-pod-abc123 \\\n  --image=busybox:1.28 \\\n  --target=webapp \\\n  --namespace=production\n\n# Debug with specific tools\nkubectl debug webapp-pod-abc123 \\\n  --image=nicolaka/netshoot:latest \\\n  --target=webapp \\\n  -n production\n"})}),"\n",(0,t.jsx)(n.h3,{id:"grant-debug-permissions-instead-of-exec",children:"Grant Debug Permissions Instead of Exec"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: debug-only\n  namespace: production\nrules:\n  - apiGroups: [""]\n    resources: ["pods/ephemeralcontainers"]\n    verbs: ["update", "patch"]\n  - apiGroups: [""]\n    resources: ["pods"]\n    verbs: ["get"]\n  # No exec or attach permissions\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: debug-binding\n  namespace: production\nsubjects:\n  - kind: User\n    name: developer@company.com\nroleRef:\n  kind: Role\n  name: debug-only\n  apiGroup: rbac.authorization.k8s.io\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"5-remove-shells-and-debugging-tools-from-production-images",children:"5. Remove Shells and Debugging Tools from Production Images"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Production containers with shells and debugging tools enable attackers to use exec for reconnaissance.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Build minimal distroless or scratch-based images without shells."]}),"\n",(0,t.jsx)(n.h3,{id:"use-distroless-base-images",children:"Use Distroless Base Images"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dockerfile",children:'# Before: Full image with shell\nFROM ubuntu:22.04\nRUN apt-get update && apt-get install -y curl wget\nCOPY app /app\nCMD ["/app"]\n\n# After: Distroless image\nFROM gcr.io/distroless/static-debian11:nonroot\nCOPY app /app\nCMD ["/app"]\n'})}),"\n",(0,t.jsx)(n.h3,{id:"verify-no-shell-in-container",children:"Verify No Shell in Container"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'# This should fail if no shell\nkubectl exec -n production webapp-pod-abc123 -- /bin/sh\n# Error: OCI runtime exec failed: exec failed: unable to start container process: exec: "/bin/sh": stat /bin/sh: no such file or directory\n'})}),"\n",(0,t.jsx)(n.h3,{id:"build-multi-stage-images",children:"Build Multi-Stage Images"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dockerfile",children:'# Build stage with tools\nFROM golang:1.21 AS builder\nWORKDIR /src\nCOPY . .\nRUN go build -o /app main.go\n\n# Production stage without tools\nFROM gcr.io/distroless/base-debian11:nonroot\nCOPY --from=builder /app /app\nCMD ["/app"]\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"6-implement-network-segmentation",children:"6. Implement Network Segmentation"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Containers with exec access can reach internal services and databases, enabling lateral movement.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Use network policies to restrict container connectivity."]}),"\n",(0,t.jsx)(n.h3,{id:"deny-egress-to-internal-services",children:"Deny Egress to Internal Services"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: restrict-database-access\n  namespace: production\nspec:\n  podSelector:\n    matchLabels:\n      app: webapp\n  policyTypes:\n    - Egress\n  egress:\n    # Allow DNS\n    - to:\n        - namespaceSelector:\n            matchLabels:\n              name: kube-system\n      ports:\n        - protocol: UDP\n          port: 53\n    # Allow only specific services\n    - to:\n        - podSelector:\n            matchLabels:\n              app: api-backend\n      ports:\n        - protocol: TCP\n          port: 8080\n    # Deny database access (not listed = denied)\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"7-monitor-and-alert-on-exec-usage",children:"7. Monitor and Alert on Exec Usage"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Without real-time monitoring, malicious exec activity goes unnoticed until damage is done.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Implement monitoring and alerting for suspicious exec patterns."]}),"\n",(0,t.jsx)(n.h3,{id:"create-falco-rules-for-exec-detection",children:"Create Falco Rules for Exec Detection"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'- rule: Suspicious Exec Command\n  desc: Detect potentially malicious exec commands\n  condition: >\n    kevt and ka.verb = create and\n    ka.target.subresource = exec and\n    (ka.uri contains "env" or\n     ka.uri contains "cat /var/run/secrets" or\n     ka.uri contains ".ssh" or\n     ka.uri contains "credentials")\n  output: >\n    Suspicious exec command detected (user=%ka.user.name\n    pod=%ka.target.name ns=%ka.target.namespace\n    command=%ka.uri)\n  priority: WARNING\n  tags: [k8s, exec, credential_access]\n\n- rule: Exec to Production Pod\n  desc: Alert on any exec to production pods\n  condition: >\n    kevt and ka.verb = create and\n    ka.target.subresource = exec and\n    ka.target.namespace = production\n  output: >\n    Exec to production pod (user=%ka.user.name\n    pod=%ka.target.name ns=%ka.target.namespace)\n  priority: WARNING\n  tags: [k8s, exec, production]\n'})}),"\n",(0,t.jsx)(n.h3,{id:"create-prometheus-alerts",children:"Create Prometheus Alerts"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'- alert: ExecToProductionPod\n  expr: |\n    increase(apiserver_audit_event_total{\n      verb="create",\n      subresource="exec",\n      namespace="production"\n    }[5m]) > 0\n  labels:\n    severity: warning\n  annotations:\n    summary: "kubectl exec used in production namespace"\n    description: "User attempted exec in production (check audit logs)"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"query-metrics",children:"Query Metrics"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Count exec operations per namespace\nkubectl top nodes\nkubectl get events -A --field-selector reason=ExecStarted\n\n# Check Prometheus metrics\ncurl -s 'http://prometheus:9090/api/v1/query?query=apiserver_audit_event_total{subresource=\"exec\"}'\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"8-use-pod-security-standards",children:"8. Use Pod Security Standards"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Privileged pods allow easier credential extraction and system compromise via exec.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Enforce restricted Pod Security Standards to limit container capabilities."]}),"\n",(0,t.jsx)(n.h3,{id:"apply-restricted-profile",children:"Apply Restricted Profile"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Namespace\nmetadata:\n  name: production\n  labels:\n    pod-security.kubernetes.io/enforce: restricted\n    pod-security.kubernetes.io/audit: restricted\n    pod-security.kubernetes.io/warn: restricted\n"})}),"\n",(0,t.jsx)(n.h3,{id:"deny-privileged-containers",children:"Deny Privileged Containers"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: webapp\n  namespace: production\nspec:\n  securityContext:\n    runAsNonRoot: true\n    runAsUser: 1000\n    seccompProfile:\n      type: RuntimeDefault\n  containers:\n    - name: app\n      image: myapp:1.0\n      securityContext:\n        allowPrivilegeEscalation: false\n        readOnlyRootFilesystem: true\n        capabilities:\n          drop:\n            - ALL\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"9-implement-break-glass-procedures",children:"9. Implement Break-Glass Procedures"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Completely blocking exec access prevents legitimate emergency debugging.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Implement time-bound break-glass access with approval workflows."]}),"\n",(0,t.jsx)(n.h3,{id:"create-just-in-time-access-request",children:"Create Just-in-Time Access Request"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: emergency-debug\n  namespace: production\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: emergency-exec\n  namespace: production\nrules:\n  - apiGroups: [""]\n    resources: ["pods/exec"]\n    verbs: ["create"]\n---\n# Initially no binding - created on-demand\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: emergency-access-user123\n  namespace: production\n  annotations:\n    expires: "2024-12-31T23:59:59Z"\n    approver: "manager@company.com"\n    ticket: "INC-12345"\nsubjects:\n  - kind: User\n    name: user@company.com\nroleRef:\n  kind: Role\n  name: emergency-exec\n  apiGroup: rbac.authorization.k8s.io\n'})}),"\n",(0,t.jsx)(n.h3,{id:"automated-expiration-script",children:"Automated Expiration Script"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n# Remove expired emergency access\n\nkubectl get rolebindings -A -o json | \\\n  jq -r \'.items[] |\n    select(.metadata.annotations.expires != null) |\n    select(.metadata.annotations.expires < now | strftime("%Y-%m-%dT%H:%M:%SZ")) |\n    "\\(.metadata.namespace) \\(.metadata.name)"\' | \\\nwhile read ns name; do\n  echo "Removing expired access: $ns/$name"\n  kubectl delete rolebinding -n "$ns" "$name"\ndone\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"security-checklist",children:"Security Checklist"}),"\n",(0,t.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Deny exec and attach permissions by default in all RBAC roles"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Grant exec/attach access only to specific pods when absolutely necessary"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement admission webhooks to validate and audit exec operations"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Enable comprehensive audit logging for pods/exec and pods/attach"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Use ephemeral debug containers instead of exec for troubleshooting"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Build distroless images without shells for production workloads"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement network policies to restrict container connectivity"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Deploy Falco rules to detect suspicious exec activity"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Set up alerts for exec operations in production namespaces"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Apply restricted Pod Security Standards to all production namespaces"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement just-in-time access with automatic expiration"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Regularly audit who has exec permissions and why"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Document legitimate use cases for exec access"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsx)(n.p,{children:"This article is based on information from the following official sources:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/rbac/",children:"Using RBAC Authorization"})," - Kubernetes Documentation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/tasks/debug/debug-application/debug-running-pod/",children:"Debug Running Pods"})," - Kubernetes Documentation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/tasks/debug/debug-cluster/audit/",children:"Auditing"})," - Kubernetes Documentation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/GoogleContainerTools/distroless",children:"Distroless Container Images"})," - Google Container Tools"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>r,x:()=>c});var i=s(6540);const t={},a=i.createContext(t);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);