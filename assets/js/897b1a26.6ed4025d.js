"use strict";(globalThis.webpackChunkk_8_s_security=globalThis.webpackChunkk_8_s_security||[]).push([[6407],{6892(e,n,s){s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"best_practices/cluster_setup_and_hardening/rbac_and_identity/service_account_token_security","title":"Kubernetes Service Account Token Security: Expiration, Lifetime & Best Practices","description":"How to secure Kubernetes service account tokens with short expiration, bound tokens, and disable auto-mounting. Covers EKS, AKS, and GKE workload identity.","source":"@site/docs/best_practices/cluster_setup_and_hardening/rbac_and_identity/service_account_token_security.md","sourceDirName":"best_practices/cluster_setup_and_hardening/rbac_and_identity","slug":"/best_practices/cluster_setup_and_hardening/rbac_and_identity/service_account_token_security","permalink":"/docs/best_practices/cluster_setup_and_hardening/rbac_and_identity/service_account_token_security","draft":false,"unlisted":false,"editUrl":"https://github.com/geek-kb/k8s_security/edit/main/docs/best_practices/cluster_setup_and_hardening/rbac_and_identity/service_account_token_security.md","tags":[],"version":"current","lastUpdatedBy":"Itai Ganot","lastUpdatedAt":1770231483000,"sidebarPosition":11,"frontMatter":{"title":"Kubernetes Service Account Token Security: Expiration, Lifetime & Best Practices","sidebar_position":11,"description":"How to secure Kubernetes service account tokens with short expiration, bound tokens, and disable auto-mounting. Covers EKS, AKS, and GKE workload identity.","keywords":["kubernetes service account token","service account token expiration","service account token lifetime","aks service account token","eks service account token","bound service account tokens","automountServiceAccountToken","workload identity","kubernetes token security","CKS"]},"sidebar":"default","previous":{"title":"Securing Kubernetes Service Accounts","permalink":"/docs/best_practices/cluster_setup_and_hardening/rbac_and_identity/service_account_mitigation"},"next":{"title":"Securing Exec and Attach Access","permalink":"/docs/best_practices/cluster_setup_and_hardening/rbac_and_identity/exec_attach_security"}}');var t=s(4848),c=s(8453);const a={title:"Kubernetes Service Account Token Security: Expiration, Lifetime & Best Practices",sidebar_position:11,description:"How to secure Kubernetes service account tokens with short expiration, bound tokens, and disable auto-mounting. Covers EKS, AKS, and GKE workload identity.",keywords:["kubernetes service account token","service account token expiration","service account token lifetime","aks service account token","eks service account token","bound service account tokens","automountServiceAccountToken","workload identity","kubernetes token security","CKS"]},o="Kubernetes Service Account Token Security",r={},l=[{value:"1. Disable Automatic Service Account Token Mounting",id:"1-disable-automatic-service-account-token-mounting",level:2},{value:"Disable at ServiceAccount Level",id:"disable-at-serviceaccount-level",level:3},{value:"Disable at Pod Level",id:"disable-at-pod-level",level:3},{value:"Set Default Deny Policy",id:"set-default-deny-policy",level:3},{value:"2. Use Bound Service Account Tokens",id:"2-use-bound-service-account-tokens",level:2},{value:"Configure Token Request Projection",id:"configure-token-request-projection",level:3},{value:"Verify Token is Bound",id:"verify-token-is-bound",level:3},{value:"Set Short Expiration Times",id:"set-short-expiration-times",level:3},{value:"3. Apply Least Privilege RBAC",id:"3-apply-least-privilege-rbac",level:2},{value:"Create Minimal Role",id:"create-minimal-role",level:3},{value:"Deny Dangerous Permissions",id:"deny-dangerous-permissions",level:3},{value:"Audit Service Account Permissions",id:"audit-service-account-permissions",level:3},{value:"4. Disable Legacy Service Account Token Secrets",id:"4-disable-legacy-service-account-token-secrets",level:2},{value:"Disable LegacyServiceAccountTokenNoAutoGeneration",id:"disable-legacyserviceaccounttokennoautogeneration",level:3},{value:"Delete Existing Legacy Tokens",id:"delete-existing-legacy-tokens",level:3},{value:"Verify No Legacy Tokens Remain",id:"verify-no-legacy-tokens-remain",level:3},{value:"5. Implement Token Request API Controls",id:"5-implement-token-request-api-controls",level:2},{value:"Deny TokenRequest Access by Default",id:"deny-tokenrequest-access-by-default",level:3},{value:"Audit TokenRequest Usage",id:"audit-tokenrequest-usage",level:3},{value:"Monitor Token Creation",id:"monitor-token-creation",level:3},{value:"6. Use Workload Identity Federation",id:"6-use-workload-identity-federation",level:2},{value:"AWS EKS with IRSA",id:"aws-eks-with-irsa",level:3},{value:"GKE with Workload Identity",id:"gke-with-workload-identity",level:3},{value:"Azure AKS with Managed Identity",id:"azure-aks-with-managed-identity",level:3},{value:"7. Implement Pod Security Admission",id:"7-implement-pod-security-admission",level:2},{value:"Enforce Restricted Profile",id:"enforce-restricted-profile",level:3},{value:"Create Admission Policy for Service Accounts",id:"create-admission-policy-for-service-accounts",level:3},{value:"8. Monitor and Audit Token Usage",id:"8-monitor-and-audit-token-usage",level:2},{value:"Enable API Server Audit Logging",id:"enable-api-server-audit-logging",level:3},{value:"Create Alerts for Suspicious Activity",id:"create-alerts-for-suspicious-activity",level:3},{value:"Query Token Usage Patterns",id:"query-token-usage-patterns",level:3},{value:"Security Checklist",id:"security-checklist",level:2},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"kubernetes-service-account-token-security",children:"Kubernetes Service Account Token Security"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Required knowledge for the CKS certification."})}),"\n",(0,t.jsx)(n.p,{children:"Service account tokens provide pods with authentication credentials for accessing the Kubernetes API server. Misconfigured tokens with excessive permissions, long expiration times, or automatic mounting create significant security risks including privilege escalation and lateral movement."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Service account tokens are automatically mounted into every pod by default, granting unnecessary API access that can be exploited if containers are compromised.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Disable automatic token mounting, use bound tokens with short expiration, and apply strict RBAC controls to limit service account permissions."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"1-disable-automatic-service-account-token-mounting",children:"1. Disable Automatic Service Account Token Mounting"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Every pod automatically mounts a service account token, even if it never needs to access the Kubernetes API.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Disable ",(0,t.jsx)(n.code,{children:"automountServiceAccountToken"})," at both ServiceAccount and Pod levels."]}),"\n",(0,t.jsx)(n.h3,{id:"disable-at-serviceaccount-level",children:"Disable at ServiceAccount Level"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: app-service-account\n  namespace: production\nautomountServiceAccountToken: false\n"})}),"\n",(0,t.jsx)(n.h3,{id:"disable-at-pod-level",children:"Disable at Pod Level"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: frontend-app\n  namespace: production\nspec:\n  serviceAccountName: app-service-account\n  automountServiceAccountToken: false\n  containers:\n    - name: nginx\n      image: nginx:1.21\n"})}),"\n",(0,t.jsx)(n.h3,{id:"set-default-deny-policy",children:"Set Default Deny Policy"}),"\n",(0,t.jsx)(n.p,{children:"Create a default service account that denies token mounting:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: default\n  namespace: production\nautomountServiceAccountToken: false\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"2-use-bound-service-account-tokens",children:"2. Use Bound Service Account Tokens"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Legacy service account tokens are long-lived (non-expiring) and can be used from anywhere, even outside the cluster.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Use bound service account tokens introduced in Kubernetes 1.21+ with audience, expiration, and bound to pod lifetime."]}),"\n",(0,t.jsx)(n.h3,{id:"configure-token-request-projection",children:"Configure Token Request Projection"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: api-client\n  namespace: production\nspec:\n  serviceAccountName: api-service-account\n  containers:\n    - name: app\n      image: myapp:1.0\n      volumeMounts:\n        - name: token\n          mountPath: /var/run/secrets/tokens\n          readOnly: true\n  volumes:\n    - name: token\n      projected:\n        sources:\n          - serviceAccountToken:\n              path: token\n              expirationSeconds: 3600\n              audience: api.company.com\n"})}),"\n",(0,t.jsx)(n.h3,{id:"verify-token-is-bound",children:"Verify Token is Bound"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Inside the pod, check token properties\nTOKEN=$(cat /var/run/secrets/tokens/token)\n\n# Decode JWT to verify expiration and audience\necho $TOKEN | cut -d '.' -f 2 | base64 -d | jq .\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Output shows:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "aud": ["api.company.com"],\n  "exp": 1702345600,\n  "iat": 1702342000,\n  "iss": "https://kubernetes.default.svc.cluster.local",\n  "kubernetes.io": {\n    "namespace": "production",\n    "pod": {\n      "name": "api-client",\n      "uid": "abc-123"\n    },\n    "serviceaccount": {\n      "name": "api-service-account",\n      "uid": "def-456"\n    }\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"set-short-expiration-times",children:"Set Short Expiration Times"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: batch-job\n  namespace: production\nspec:\n  serviceAccountName: batch-sa\n  containers:\n    - name: worker\n      image: worker:1.0\n      volumeMounts:\n        - name: token\n          mountPath: /var/run/secrets/tokens\n  volumes:\n    - name: token\n      projected:\n        sources:\n          - serviceAccountToken:\n              path: token\n              expirationSeconds: 600 # 10 minutes\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"3-apply-least-privilege-rbac",children:"3. Apply Least Privilege RBAC"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Service accounts often have overly broad permissions granting access to resources they don't need.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Apply principle of least privilege and grant only the minimum required permissions."]}),"\n",(0,t.jsx)(n.h3,{id:"create-minimal-role",children:"Create Minimal Role"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: configmap-reader\n  namespace: production\nrules:\n  - apiGroups: [""]\n    resources: ["configmaps"]\n    verbs: ["get", "list"]\n    resourceNames: ["app-config"] # Restrict to specific ConfigMap\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: app-configmap-reader\n  namespace: production\nsubjects:\n  - kind: ServiceAccount\n    name: app-service-account\n    namespace: production\nroleRef:\n  kind: Role\n  name: configmap-reader\n  apiGroup: rbac.authorization.k8s.io\n'})}),"\n",(0,t.jsx)(n.h3,{id:"deny-dangerous-permissions",children:"Deny Dangerous Permissions"}),"\n",(0,t.jsx)(n.p,{children:"Never grant these permissions to application service accounts:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'# DANGEROUS - DO NOT USE\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: dangerous-role\n  namespace: production\nrules:\n  # NEVER allow secrets access\n  - apiGroups: [""]\n    resources: ["secrets"]\n    verbs: ["get", "list"]\n\n  # NEVER allow pod creation\n  - apiGroups: [""]\n    resources: ["pods"]\n    verbs: ["create"]\n\n  # NEVER allow serviceaccounts/token\n  - apiGroups: [""]\n    resources: ["serviceaccounts/token"]\n    verbs: ["create"]\n'})}),"\n",(0,t.jsx)(n.h3,{id:"audit-service-account-permissions",children:"Audit Service Account Permissions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'# List all service accounts with their roles\nkubectl get rolebindings,clusterrolebindings -A -o json | \\\n  jq \'.items[] | select(.subjects[]?.kind == "ServiceAccount")\'\n\n# Check specific service account permissions\nkubectl auth can-i --list --as=system:serviceaccount:production:app-sa\n\n# Find service accounts with secrets access\nkubectl get roles,clusterroles -A -o json | \\\n  jq \'.items[] | select(.rules[]? | select(.resources[]? == "secrets" and (.verbs[]? == "get" or .verbs[]? == "*")))\'\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"4-disable-legacy-service-account-token-secrets",children:"4. Disable Legacy Service Account Token Secrets"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Pre-1.24 clusters automatically create non-expiring token secrets for each service account.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Disable automatic token secret creation and clean up existing legacy tokens."]}),"\n",(0,t.jsx)(n.h3,{id:"disable-legacyserviceaccounttokennoautogeneration",children:"Disable LegacyServiceAccountTokenNoAutoGeneration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Add to kube-apiserver flags\nkube-apiserver \\\n  --feature-gates=LegacyServiceAccountTokenNoAutoGeneration=true\n"})}),"\n",(0,t.jsx)(n.h3,{id:"delete-existing-legacy-tokens",children:"Delete Existing Legacy Tokens"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'# List all legacy token secrets\nkubectl get secrets -A -o json | \\\n  jq -r \'.items[] | select(.type=="kubernetes.io/service-account-token") | "\\(.metadata.namespace) \\(.metadata.name)"\'\n\n# Delete legacy tokens (be careful!)\nkubectl delete secret -n production default-token-xxxxx\n'})}),"\n",(0,t.jsx)(n.h3,{id:"verify-no-legacy-tokens-remain",children:"Verify No Legacy Tokens Remain"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Check service accounts have no token secrets\nkubectl get sa app-sa -n production -o jsonpath='{.secrets}'\n\n# Should return empty: []\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"5-implement-token-request-api-controls",children:"5. Implement Token Request API Controls"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," The TokenRequest API can be abused to generate tokens for any service account if permissions are too broad.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Restrict access to the serviceaccounts/token subresource."]}),"\n",(0,t.jsx)(n.h3,{id:"deny-tokenrequest-access-by-default",children:"Deny TokenRequest Access by Default"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: no-token-request\nrules:\n  # Explicitly deny token creation\n  - apiGroups: [""]\n    resources: ["serviceaccounts/token"]\n    verbs: [] # Empty verbs = no access\n'})}),"\n",(0,t.jsx)(n.h3,{id:"audit-tokenrequest-usage",children:"Audit TokenRequest Usage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: audit.k8s.io/v1\nkind: Policy\nrules:\n  - level: RequestResponse\n    verbs: ["create"]\n    resources:\n      - group: ""\n        resources: ["serviceaccounts/token"]\n    omitStages:\n      - RequestReceived\n'})}),"\n",(0,t.jsx)(n.h3,{id:"monitor-token-creation",children:"Monitor Token Creation"}),"\n",(0,t.jsx)(n.p,{children:"Using Falco:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"- rule: Suspicious Token Request\n  desc: Detect TokenRequest API abuse\n  condition: >\n    kevt and ka.verb = create and\n    ka.target.resource = serviceaccounts/token and\n    ka.target.subresource = token\n  output: >\n    TokenRequest API called (user=%ka.user.name\n    target_sa=%ka.target.name ns=%ka.target.namespace)\n  priority: WARNING\n  tags: [k8s, token, privilege_escalation]\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"6-use-workload-identity-federation",children:"6. Use Workload Identity Federation"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Service account tokens provide cluster API access when applications only need external service authentication.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Use workload identity to authenticate to external services without cluster API access."]}),"\n",(0,t.jsx)(n.h3,{id:"aws-eks-with-irsa",children:"AWS EKS with IRSA"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: s3-access-sa\n  namespace: production\n  annotations:\n    eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/S3AccessRole\nautomountServiceAccountToken: false # No cluster API access needed\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: s3-app\n  namespace: production\nspec:\n  serviceAccountName: s3-access-sa\n  containers:\n    - name: app\n      image: myapp:1.0\n      env:\n        - name: AWS_ROLE_ARN\n          value: arn:aws:iam::123456789012:role/S3AccessRole\n        - name: AWS_WEB_IDENTITY_TOKEN_FILE\n          value: /var/run/secrets/eks.amazonaws.com/serviceaccount/token\n"})}),"\n",(0,t.jsx)(n.h3,{id:"gke-with-workload-identity",children:"GKE with Workload Identity"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: gcs-access-sa\n  namespace: production\n  annotations:\n    iam.gke.io/gcp-service-account: gcs-accessor@project.iam.gserviceaccount.com\nautomountServiceAccountToken: false\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: gcs-app\n  namespace: production\nspec:\n  serviceAccountName: gcs-access-sa\n  containers:\n    - name: app\n      image: myapp:1.0\n"})}),"\n",(0,t.jsx)(n.p,{children:"Bind the GCP service account:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'gcloud iam service-accounts add-iam-policy-binding \\\n  gcs-accessor@project.iam.gserviceaccount.com \\\n  --role roles/iam.workloadIdentityUser \\\n  --member "serviceAccount:project.svc.id.goog[production/gcs-access-sa]"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"azure-aks-with-managed-identity",children:"Azure AKS with Managed Identity"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: storage-access-sa\n  namespace: production\n  annotations:\n    azure.workload.identity/client-id: "12345678-1234-1234-1234-123456789012"\nautomountServiceAccountToken: false\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: storage-app\n  namespace: production\n  labels:\n    azure.workload.identity/use: "true"\nspec:\n  serviceAccountName: storage-access-sa\n  containers:\n    - name: app\n      image: myapp:1.0\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"7-implement-pod-security-admission",children:"7. Implement Pod Security Admission"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Pods can be created with service accounts that have excessive privileges without validation.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Use Pod Security Admission to enforce controls on service account usage."]}),"\n",(0,t.jsx)(n.h3,{id:"enforce-restricted-profile",children:"Enforce Restricted Profile"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Namespace\nmetadata:\n  name: production\n  labels:\n    pod-security.kubernetes.io/enforce: restricted\n    pod-security.kubernetes.io/audit: restricted\n    pod-security.kubernetes.io/warn: restricted\n"})}),"\n",(0,t.jsx)(n.h3,{id:"create-admission-policy-for-service-accounts",children:"Create Admission Policy for Service Accounts"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: admissionregistration.k8s.io/v1\nkind: ValidatingAdmissionPolicy\nmetadata:\n  name: require-token-disabled\nspec:\n  failurePolicy: Fail\n  matchConstraints:\n    resourceRules:\n      - apiGroups: [""]\n        apiVersions: ["v1"]\n        operations: ["CREATE", "UPDATE"]\n        resources: ["pods"]\n  validations:\n    - expression: "object.spec.automountServiceAccountToken == false"\n      message: "Pods must explicitly disable service account token mounting"\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"8-monitor-and-audit-token-usage",children:"8. Monitor and Audit Token Usage"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Service account token abuse goes undetected without proper monitoring.",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.strong,{children:"Fix:"})," Implement comprehensive audit logging and alerting for token-related activity."]}),"\n",(0,t.jsx)(n.h3,{id:"enable-api-server-audit-logging",children:"Enable API Server Audit Logging"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: audit.k8s.io/v1\nkind: Policy\nrules:\n  - level: RequestResponse\n    verbs: ["create"]\n    resources:\n      - group: ""\n        resources: ["serviceaccounts", "serviceaccounts/token"]\n  - level: Metadata\n    verbs: ["impersonate"]\n    resources:\n      - group: ""\n        resources: ["serviceaccounts"]\n'})}),"\n",(0,t.jsx)(n.h3,{id:"create-alerts-for-suspicious-activity",children:"Create Alerts for Suspicious Activity"}),"\n",(0,t.jsx)(n.p,{children:"Using Prometheus + AlertManager:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'- alert: ServiceAccountTokenCreated\n  expr: |\n    increase(apiserver_audit_event_total{\n      verb="create",\n      objectRef_resource="serviceaccounts",\n      objectRef_subresource="token"\n    }[5m]) > 0\n  labels:\n    severity: warning\n  annotations:\n    summary: "Service account token created via API"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"query-token-usage-patterns",children:"Query Token Usage Patterns"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Find pods with mounted tokens\nkubectl get pods -A -o json | \\\n  jq '.items[] | select(.spec.automountServiceAccountToken != false)'\n\n# Check API audit logs for token usage\nkubectl logs -n kube-system kube-apiserver-master | \\\n  grep \"serviceaccounts/token\"\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"security-checklist",children:"Security Checklist"}),"\n",(0,t.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Disable ",(0,t.jsx)(n.code,{children:"automountServiceAccountToken"})," by default for all service accounts"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Use bound service account tokens with short expiration (< 1 hour)"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Apply least privilege RBAC to all service accounts"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Remove permissions for secrets, pods, and serviceaccounts/token"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Disable legacy service account token secret creation"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Delete existing non-expiring token secrets"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Use workload identity federation for external service authentication"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement Pod Security Admission with restricted profile"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Enable comprehensive audit logging for token-related operations"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Monitor TokenRequest API usage with alerts"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Regularly audit service account permissions"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Document which service accounts require API access and why"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsx)(n.p,{children:"This article is based on information from the following official sources:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/security/service-accounts/",children:"Service Accounts"})," - Kubernetes Documentation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/#bound-service-account-tokens",children:"Bound Service Account Tokens"})," - Kubernetes Documentation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",children:"Configure Service Accounts for Pods"})," - Kubernetes Documentation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/security/pod-security-admission/",children:"Pod Security Admission"})," - Kubernetes Documentation"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>a,x:()=>o});var i=s(6540);const t={},c=i.createContext(t);function a(e){const n=i.useContext(c);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(c.Provider,{value:n},e.children)}}}]);