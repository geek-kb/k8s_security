"use strict";(globalThis.webpackChunkk_8_s_security=globalThis.webpackChunkk_8_s_security||[]).push([[8230],{4601(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"best-practices/cluster-setup-and-hardening/network-security/netchecks","title":"netchecks","description":"netchecks validates network connectivity assumptions in Kubernetes clusters by running declarative network tests to verify policies and connectivity.","source":"@site/docs/best-practices/cluster-setup-and-hardening/network-security/netchecks.md","sourceDirName":"best-practices/cluster-setup-and-hardening/network-security","slug":"/best-practices/cluster-setup-and-hardening/network-security/netchecks","permalink":"/kubernetes-security/best-practices/cluster-setup-and-hardening/network-security/netchecks","draft":false,"unlisted":false,"editUrl":"https://github.com/geek-kb/k8s_security/edit/main/docs/best-practices/cluster-setup-and-hardening/network-security/netchecks.md","tags":[{"inline":true,"label":"tool","permalink":"/kubernetes-security/tags/tool"},{"inline":true,"label":"network","permalink":"/kubernetes-security/tags/network"},{"inline":true,"label":"network-policies","permalink":"/kubernetes-security/tags/network-policies"},{"inline":true,"label":"CKS","permalink":"/kubernetes-security/tags/cks"}],"version":"current","lastUpdatedBy":"Itai Ganot","lastUpdatedAt":1771236448000,"sidebarPosition":17,"frontMatter":{"sidebar_position":17,"title":"netchecks","description":"netchecks validates network connectivity assumptions in Kubernetes clusters by running declarative network tests to verify policies and connectivity.","keywords":["kubernetes security tool","netchecks","network testing","network policies","connectivity validation","network security","kubernetes networking","CKS"],"tags":["tool","network","network-policies","CKS"],"related":["/kubernetes-security/best-practices/cluster-setup-and-hardening/network-security/network-policies/","/kubernetes-security/best-practices/cluster-setup-and-hardening/network-security/cilium/","/kubernetes-security/attack-vectors/lack-of-network-policies/"]},"sidebar":"default","previous":{"title":"Cloud Metadata Service Mitigation","permalink":"/kubernetes-security/best-practices/cluster-setup-and-hardening/network-security/cloud-metadata-mitigation"},"next":{"title":"Kubelet Security Overview","permalink":"/kubernetes-security/best-practices/cluster-setup-and-hardening/node-security/kubelet-security"}}');var i=t(4848),c=t(8453);const r={sidebar_position:17,title:"netchecks",description:"netchecks validates network connectivity assumptions in Kubernetes clusters by running declarative network tests to verify policies and connectivity.",keywords:["kubernetes security tool","netchecks","network testing","network policies","connectivity validation","network security","kubernetes networking","CKS"],tags:["tool","network","network-policies","CKS"],related:["/kubernetes-security/best-practices/cluster-setup-and-hardening/network-security/network-policies/","/kubernetes-security/best-practices/cluster-setup-and-hardening/network-security/cilium/","/kubernetes-security/attack-vectors/lack-of-network-policies/"]},l="netchecks",a={},o=[{value:"Use Cases",id:"use-cases",level:2},{value:"Installation",id:"installation",level:2},{value:"Using Helm",id:"using-helm",level:3},{value:"Using kubectl",id:"using-kubectl",level:3},{value:"Core Concepts",id:"core-concepts",level:2},{value:"NetworkAssertion",id:"networkassertion",level:3},{value:"Rule Types",id:"rule-types",level:3},{value:"Basic Examples",id:"basic-examples",level:2},{value:"Verify Service Connectivity",id:"verify-service-connectivity",level:3},{value:"Verify Network Policy Blocks Traffic",id:"verify-network-policy-blocks-traffic",level:3},{value:"DNS Resolution Check",id:"dns-resolution-check",level:3},{value:"Egress Policy Verification",id:"egress-policy-verification",level:3},{value:"Scheduled Checks",id:"scheduled-checks",level:2},{value:"Viewing Results",id:"viewing-results",level:2},{value:"Check NetworkAssertion Status",id:"check-networkassertion-status",level:3},{value:"Get Detailed Results",id:"get-detailed-results",level:3},{value:"View Test Logs",id:"view-test-logs",level:3},{value:"Integration with CI/CD",id:"integration-with-cicd",level:2},{value:"GitHub Actions Example",id:"github-actions-example",level:3},{value:"Testing Network Policies",id:"testing-network-policies",level:2},{value:"Example: Test Default Deny Policy",id:"example-test-default-deny-policy",level:3},{value:"Example: Test Allow List Policy",id:"example-test-allow-list-policy",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"netchecks",children:"netchecks"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"netchecks"})," is a Kubernetes-native tool for validating network connectivity and verifying that network policies work as expected. It runs declarative network tests from within the cluster, checking that expected connections succeed and blocked connections fail."]}),"\n",(0,i.jsx)(n.p,{children:"This tool is essential for verifying network policy implementations and ensuring network segmentation is working correctly."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Validate that network policies block expected traffic."}),"\n",(0,i.jsx)(n.li,{children:"Verify connectivity between services after policy changes."}),"\n",(0,i.jsx)(n.li,{children:"Continuous network security testing in CI/CD pipelines."}),"\n",(0,i.jsx)(n.li,{children:"Troubleshoot network connectivity issues."}),"\n",(0,i.jsx)(n.li,{children:"Document and enforce network segmentation requirements."}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,i.jsx)(n.h3,{id:"using-helm",children:"Using Helm"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"helm repo add netchecks https://hardbyte.github.io/netchecks\nhelm install netchecks netchecks/netchecks --namespace netchecks --create-namespace\n"})}),"\n",(0,i.jsx)(n.h3,{id:"using-kubectl",children:"Using kubectl"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl apply -f https://raw.githubusercontent.com/hardbyte/netchecks/main/deploy/install.yaml\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,i.jsx)(n.h3,{id:"networkassertion",children:"NetworkAssertion"}),"\n",(0,i.jsx)(n.p,{children:"A custom resource that defines expected network connectivity:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'apiVersion: netchecks.io/v1\nkind: NetworkAssertion\nmetadata:\n  name: check-database-connectivity\n  namespace: production\nspec:\n  schedule: "*/5 * * * *"  # Every 5 minutes\n  rules:\n    - name: backend-can-reach-database\n      type: http\n      url: http://database-service:5432\n      expected: pass\n      \n    - name: frontend-cannot-reach-database\n      type: http\n      url: http://database-service:5432\n      sourceNamespace: frontend\n      expected: fail\n'})}),"\n",(0,i.jsx)(n.h3,{id:"rule-types",children:"Rule Types"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"http"}),(0,i.jsx)(n.td,{children:"HTTP/HTTPS connectivity check"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"tcp"}),(0,i.jsx)(n.td,{children:"TCP port connectivity"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"dns"}),(0,i.jsx)(n.td,{children:"DNS resolution check"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"icmp"}),(0,i.jsx)(n.td,{children:"ICMP ping check"})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"basic-examples",children:"Basic Examples"}),"\n",(0,i.jsx)(n.h3,{id:"verify-service-connectivity",children:"Verify Service Connectivity"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: netchecks.io/v1\nkind: NetworkAssertion\nmetadata:\n  name: service-connectivity\n  namespace: production\nspec:\n  rules:\n    - name: api-to-database\n      type: tcp\n      host: postgres-service\n      port: 5432\n      expected: pass\n      \n    - name: api-to-cache\n      type: tcp\n      host: redis-service\n      port: 6379\n      expected: pass\n"})}),"\n",(0,i.jsx)(n.h3,{id:"verify-network-policy-blocks-traffic",children:"Verify Network Policy Blocks Traffic"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: netchecks.io/v1\nkind: NetworkAssertion\nmetadata:\n  name: policy-enforcement\n  namespace: production\nspec:\n  rules:\n    # This should be blocked by network policy\n    - name: external-cannot-reach-internal\n      type: tcp\n      host: internal-service.internal-namespace\n      port: 80\n      expected: fail\n      \n    # This should be allowed\n    - name: internal-can-reach-internal\n      type: tcp\n      host: internal-service\n      port: 80\n      expected: pass\n"})}),"\n",(0,i.jsx)(n.h3,{id:"dns-resolution-check",children:"DNS Resolution Check"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: netchecks.io/v1\nkind: NetworkAssertion\nmetadata:\n  name: dns-checks\n  namespace: production\nspec:\n  rules:\n    - name: internal-dns-works\n      type: dns\n      host: kubernetes.default.svc.cluster.local\n      expected: pass\n      \n    - name: external-dns-works\n      type: dns\n      host: google.com\n      expected: pass\n"})}),"\n",(0,i.jsx)(n.h3,{id:"egress-policy-verification",children:"Egress Policy Verification"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: netchecks.io/v1\nkind: NetworkAssertion\nmetadata:\n  name: egress-policy-check\n  namespace: restricted\nspec:\n  rules:\n    # Should be allowed to specific external service\n    - name: can-reach-allowed-api\n      type: http\n      url: https://api.allowed-service.com/health\n      expected: pass\n      \n    # Should be blocked from reaching arbitrary internet\n    - name: cannot-reach-internet\n      type: http\n      url: https://google.com\n      expected: fail\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"scheduled-checks",children:"Scheduled Checks"}),"\n",(0,i.jsx)(n.p,{children:"Run checks on a schedule for continuous validation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'apiVersion: netchecks.io/v1\nkind: NetworkAssertion\nmetadata:\n  name: continuous-network-validation\nspec:\n  schedule: "*/15 * * * *"  # Every 15 minutes\n  rules:\n    - name: critical-service-connectivity\n      type: tcp\n      host: critical-service\n      port: 443\n      expected: pass\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"viewing-results",children:"Viewing Results"}),"\n",(0,i.jsx)(n.h3,{id:"check-networkassertion-status",children:"Check NetworkAssertion Status"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl get networkassertions -A\n"})}),"\n",(0,i.jsx)(n.p,{children:"Example output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"NAMESPACE    NAME                    STATUS   LAST RUN              PASSED   FAILED\nproduction   service-connectivity    Passed   2024-01-15T10:30:00Z  3        0\nproduction   policy-enforcement      Failed   2024-01-15T10:30:00Z  1        1\n"})}),"\n",(0,i.jsx)(n.h3,{id:"get-detailed-results",children:"Get Detailed Results"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl describe networkassertion service-connectivity -n production\n"})}),"\n",(0,i.jsx)(n.h3,{id:"view-test-logs",children:"View Test Logs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl logs -n netchecks -l app=netchecks-runner\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"integration-with-cicd",children:"Integration with CI/CD"}),"\n",(0,i.jsx)(n.h3,{id:"github-actions-example",children:"GitHub Actions Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'name: Network Policy Validation\non:\n  push:\n    paths:\n      - \'kubernetes/network-policies/**\'\n\njobs:\n  validate-policies:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Setup cluster\n        uses: helm/kind-action@v1\n        \n      - name: Apply network policies\n        run: kubectl apply -f kubernetes/network-policies/\n        \n      - name: Install netchecks\n        run: |\n          helm repo add netchecks https://hardbyte.github.io/netchecks\n          helm install netchecks netchecks/netchecks -n netchecks --create-namespace\n          \n      - name: Run network assertions\n        run: |\n          kubectl apply -f kubernetes/network-assertions/\n          sleep 60\n          kubectl get networkassertions -A -o json | jq \'.items[] | select(.status.phase != "Passed")\'\n          \n      - name: Fail if assertions failed\n        run: |\n          FAILED=$(kubectl get networkassertions -A -o json | jq \'[.items[] | select(.status.phase == "Failed")] | length\')\n          if [ "$FAILED" -gt 0 ]; then\n            echo "Network assertions failed!"\n            exit 1\n          fi\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"testing-network-policies",children:"Testing Network Policies"}),"\n",(0,i.jsx)(n.h3,{id:"example-test-default-deny-policy",children:"Example: Test Default Deny Policy"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Apply a default deny policy:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: default-deny-ingress\n  namespace: secure\nspec:\n  podSelector: {}\n  policyTypes:\n    - Ingress\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Create a NetworkAssertion to verify:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: netchecks.io/v1\nkind: NetworkAssertion\nmetadata:\n  name: verify-default-deny\n  namespace: secure\nspec:\n  rules:\n    # Should fail because default deny is in place\n    - name: external-blocked\n      type: tcp\n      host: secure-service\n      port: 80\n      sourceNamespace: other-namespace\n      expected: fail\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-test-allow-list-policy",children:"Example: Test Allow List Policy"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Apply a policy allowing specific traffic:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-from-frontend\n  namespace: backend\nspec:\n  podSelector:\n    matchLabels:\n      app: api\n  policyTypes:\n    - Ingress\n  ingress:\n    - from:\n        - namespaceSelector:\n            matchLabels:\n              name: frontend\n      ports:\n        - port: 8080\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Verify with NetworkAssertion:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: netchecks.io/v1\nkind: NetworkAssertion\nmetadata:\n  name: verify-allowlist\n  namespace: backend\nspec:\n  rules:\n    - name: frontend-can-reach-api\n      type: tcp\n      host: api-service\n      port: 8080\n      sourceNamespace: frontend\n      expected: pass\n      \n    - name: other-cannot-reach-api\n      type: tcp\n      host: api-service\n      port: 8080\n      sourceNamespace: other\n      expected: fail\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Test both allow and deny:"})," Verify that expected traffic works AND unexpected traffic is blocked."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use scheduling:"})," Run checks continuously to detect policy drift."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Version control assertions:"})," Keep NetworkAssertion manifests alongside network policies."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Integrate with CI/CD:"})," Validate policies before deploying to production."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Document requirements:"})," Use NetworkAssertions as living documentation of network requirements."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsx)(n.p,{children:"This article is based on information from the following official sources:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/hardbyte/netchecks",children:"netchecks GitHub Repository"})," - GitHub"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/network-policies/",children:"Network Policies"})," - Kubernetes Documentation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/tasks/administer-cluster/declare-network-policy/",children:"Network Policy Testing"})," - Kubernetes Documentation"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>r,x:()=>l});var s=t(6540);const i={},c=s.createContext(i);function r(e){const n=s.useContext(c);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(c.Provider,{value:n},e.children)}}}]);