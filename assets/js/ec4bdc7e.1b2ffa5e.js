"use strict";(globalThis.webpackChunkk_8_s_security=globalThis.webpackChunkk_8_s_security||[]).push([[4646],{1833(e,s,n){n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"best_practices/cluster_setup_and_hardening/pod_security/persistent_volume_security","title":"Securing Persistent Volumes","description":"How to protect Kubernetes PersistentVolumes from unauthorized access, data exposure, and cross-namespace attacks through proper configuration and RBAC.","source":"@site/docs/best_practices/cluster_setup_and_hardening/pod_security/persistent_volume_security.md","sourceDirName":"best_practices/cluster_setup_and_hardening/pod_security","slug":"/best_practices/cluster_setup_and_hardening/pod_security/persistent_volume_security","permalink":"/docs/best_practices/cluster_setup_and_hardening/pod_security/persistent_volume_security","draft":false,"unlisted":false,"editUrl":"https://github.com/geek-kb/k8s_security/edit/main/docs/best_practices/cluster_setup_and_hardening/pod_security/persistent_volume_security.md","tags":[{"inline":true,"label":"best-practice","permalink":"/docs/tags/best-practice"},{"inline":true,"label":"mitigation","permalink":"/docs/tags/mitigation"},{"inline":true,"label":"storage","permalink":"/docs/tags/storage"},{"inline":true,"label":"pod-security","permalink":"/docs/tags/pod-security"},{"inline":true,"label":"CKS","permalink":"/docs/tags/cks"}],"version":"current","lastUpdatedBy":"Itai Ganot","lastUpdatedAt":1770658335000,"sidebarPosition":11,"frontMatter":{"sidebar_position":11,"title":"Securing Persistent Volumes","description":"How to protect Kubernetes PersistentVolumes from unauthorized access, data exposure, and cross-namespace attacks through proper configuration and RBAC.","keywords":["kubernetes security best practices","persistent volume security","PV security","storage security","data protection","PVC RBAC","reclaim policy","storage class","volume encryption","CKS"],"tags":["best-practice","mitigation","storage","pod-security","CKS"],"related":["/docs/attack_vectors/persistent_volume_data_exposure/","/docs/attack_vectors/unrestricted_hostpath_mounts/","/docs/best_practices/cluster_setup_and_hardening/secrets_management/insecure_secrets_management_mitigation/"]},"sidebar":"default","previous":{"title":"Security Profiles Operator","permalink":"/docs/best_practices/cluster_setup_and_hardening/pod_security/security_profiles_operator"},"next":{"title":"kube-psp-advisor","permalink":"/docs/best_practices/cluster_setup_and_hardening/pod_security/kube_psp_advisor"}}');var i=n(4848),r=n(8453);const a={sidebar_position:11,title:"Securing Persistent Volumes",description:"How to protect Kubernetes PersistentVolumes from unauthorized access, data exposure, and cross-namespace attacks through proper configuration and RBAC.",keywords:["kubernetes security best practices","persistent volume security","PV security","storage security","data protection","PVC RBAC","reclaim policy","storage class","volume encryption","CKS"],tags:["best-practice","mitigation","storage","pod-security","CKS"],related:["/docs/attack_vectors/persistent_volume_data_exposure/","/docs/attack_vectors/unrestricted_hostpath_mounts/","/docs/best_practices/cluster_setup_and_hardening/secrets_management/insecure_secrets_management_mitigation/"]},o="Securing Persistent Volumes",c={},l=[{value:"1. Use Delete Reclaim Policy",id:"1-use-delete-reclaim-policy",level:2},{value:"Configure Storage Class with Delete Policy",id:"configure-storage-class-with-delete-policy",level:3},{value:"Update Existing PVs",id:"update-existing-pvs",level:3},{value:"Scrub Released Volumes",id:"scrub-released-volumes",level:3},{value:"2. Restrict PVC Creation with RBAC",id:"2-restrict-pvc-creation-with-rbac",level:2},{value:"Create Restrictive PVC Role",id:"create-restrictive-pvc-role",level:3},{value:"Namespace-Level PVC Quotas",id:"namespace-level-pvc-quotas",level:3},{value:"3. Use Namespace-Scoped Storage Classes",id:"3-use-namespace-scoped-storage-classes",level:2},{value:"Kyverno Policy to Restrict Storage Classes",id:"kyverno-policy-to-restrict-storage-classes",level:3},{value:"4. Enforce Volume Encryption",id:"4-enforce-volume-encryption",level:2},{value:"AWS EBS Encryption",id:"aws-ebs-encryption",level:3},{value:"GCP PD Encryption",id:"gcp-pd-encryption",level:3},{value:"Admission Policy to Require Encryption",id:"admission-policy-to-require-encryption",level:3},{value:"5. Restrict Access Modes",id:"5-restrict-access-modes",level:2},{value:"Admission Policy to Block RWX in Production",id:"admission-policy-to-block-rwx-in-production",level:3},{value:"Audit Existing RWX Volumes",id:"audit-existing-rwx-volumes",level:3},{value:"6. Implement Volume Snapshots Securely",id:"6-implement-volume-snapshots-securely",level:2},{value:"Restrict Snapshot Permissions",id:"restrict-snapshot-permissions",level:3},{value:"Secure Snapshot Class",id:"secure-snapshot-class",level:3},{value:"7. Monitor and Audit Volume Access",id:"7-monitor-and-audit-volume-access",level:2},{value:"API Server Audit Policy",id:"api-server-audit-policy",level:3},{value:"Falco Rules for Volume Access",id:"falco-rules-for-volume-access",level:3},{value:"Security Checklist",id:"security-checklist",level:2},{value:"References",id:"references",level:2}];function d(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"securing-persistent-volumes",children:"Securing Persistent Volumes"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Required knowledge for the CKS certification."})}),"\n",(0,i.jsx)(s.p,{children:"PersistentVolumes (PVs) can expose sensitive data if improperly configured. Common risks include orphaned volumes retaining data, cross-namespace access through shared volumes, and lack of encryption. Attackers who gain the ability to create pods or PersistentVolumeClaims may access data belonging to other workloads."}),"\n",(0,i.jsx)(s.p,{children:"This guide covers best practices for securing PersistentVolumes in Kubernetes."}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"1-use-delete-reclaim-policy",children:"1. Use Delete Reclaim Policy"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Issue:"})," The ",(0,i.jsx)(s.code,{children:"Retain"})," reclaim policy keeps volume data after PVC deletion, allowing future claims to access old data.",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(s.strong,{children:"Fix:"})," Use ",(0,i.jsx)(s.code,{children:"Delete"})," reclaim policy to ensure data is removed when PVCs are deleted."]}),"\n",(0,i.jsx)(s.h3,{id:"configure-storage-class-with-delete-policy",children:"Configure Storage Class with Delete Policy"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-yaml",children:'apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: secure-storage\nprovisioner: kubernetes.io/aws-ebs\nreclaimPolicy: Delete\nvolumeBindingMode: WaitForFirstConsumer\nparameters:\n  type: gp3\n  encrypted: "true"\n'})}),"\n",(0,i.jsx)(s.h3,{id:"update-existing-pvs",children:"Update Existing PVs"}),"\n",(0,i.jsxs)(s.p,{children:["For existing PVs with ",(0,i.jsx)(s.code,{children:"Retain"})," policy that need to be cleaned up:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:'# List PVs with Retain policy\nkubectl get pv -o json | jq -r \'.items[] | \n  select(.spec.persistentVolumeReclaimPolicy == "Retain") | \n  .metadata.name\'\n\n# Update to Delete policy (be careful - verify data is backed up)\nkubectl patch pv <pv-name> -p \'{"spec":{"persistentVolumeReclaimPolicy":"Delete"}}\'\n'})}),"\n",(0,i.jsx)(s.h3,{id:"scrub-released-volumes",children:"Scrub Released Volumes"}),"\n",(0,i.jsxs)(s.p,{children:["If you must use ",(0,i.jsx)(s.code,{children:"Retain"}),", implement a volume scrubbing process:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:'# Identify released volumes\nkubectl get pv | grep Released\n\n# For each released volume, create a temporary pod to wipe data\nkubectl run scrubber --rm -it --image=busybox \\\n  --overrides=\'{"spec":{"volumes":[{"name":"data","persistentVolumeClaim":{"claimName":"orphaned-pvc"}}],"containers":[{"name":"scrubber","image":"busybox","command":["sh","-c","rm -rf /data/*"],"volumeMounts":[{"name":"data","mountPath":"/data"}]}]}}\'\n'})}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"2-restrict-pvc-creation-with-rbac",children:"2. Restrict PVC Creation with RBAC"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Issue:"})," Users who can create PVCs may bind to PVs containing data from other namespaces.",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(s.strong,{children:"Fix:"})," Restrict PVC creation to authorized users and namespaces."]}),"\n",(0,i.jsx)(s.h3,{id:"create-restrictive-pvc-role",children:"Create Restrictive PVC Role"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-yaml",children:'apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pvc-user\n  namespace: production\nrules:\n  - apiGroups: [""]\n    resources: ["persistentvolumeclaims"]\n    verbs: ["get", "list", "watch"]\n    # Note: create/delete omitted - only admins can manage PVCs\n'})}),"\n",(0,i.jsx)(s.h3,{id:"namespace-level-pvc-quotas",children:"Namespace-Level PVC Quotas"}),"\n",(0,i.jsx)(s.p,{children:"Limit PVC creation in namespaces:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-yaml",children:'apiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: storage-quota\n  namespace: development\nspec:\n  hard:\n    persistentvolumeclaims: "5"\n    requests.storage: "50Gi"\n'})}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"3-use-namespace-scoped-storage-classes",children:"3. Use Namespace-Scoped Storage Classes"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Issue:"})," Cluster-wide StorageClasses allow any namespace to provision volumes.",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(s.strong,{children:"Fix:"})," Use admission control to restrict which namespaces can use specific StorageClasses."]}),"\n",(0,i.jsx)(s.h3,{id:"kyverno-policy-to-restrict-storage-classes",children:"Kyverno Policy to Restrict Storage Classes"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-yaml",children:'apiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: restrict-storage-classes\nspec:\n  validationFailureAction: Enforce\n  rules:\n    - name: restrict-premium-storage\n      match:\n        any:\n          - resources:\n              kinds:\n                - PersistentVolumeClaim\n      validate:\n        message: "Premium storage class is only allowed in production namespace"\n        deny:\n          conditions:\n            all:\n              - key: "{{ request.object.spec.storageClassName }}"\n                operator: Equals\n                value: "premium-ssd"\n              - key: "{{ request.namespace }}"\n                operator: NotIn\n                value: ["production", "database"]\n'})}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"4-enforce-volume-encryption",children:"4. Enforce Volume Encryption"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Issue:"})," Unencrypted volumes expose data if the underlying storage is compromised.",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(s.strong,{children:"Fix:"})," Require encryption for all PersistentVolumes."]}),"\n",(0,i.jsx)(s.h3,{id:"aws-ebs-encryption",children:"AWS EBS Encryption"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-yaml",children:'apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: encrypted-gp3\nprovisioner: ebs.csi.aws.com\nparameters:\n  type: gp3\n  encrypted: "true"\n  kmsKeyId: "arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"\n'})}),"\n",(0,i.jsx)(s.h3,{id:"gcp-pd-encryption",children:"GCP PD Encryption"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-yaml",children:'apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: encrypted-pd\nprovisioner: pd.csi.storage.gke.io\nparameters:\n  type: pd-ssd\n  disk-encryption-kms-key: "projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key"\n'})}),"\n",(0,i.jsx)(s.h3,{id:"admission-policy-to-require-encryption",children:"Admission Policy to Require Encryption"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-yaml",children:'apiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: require-encrypted-storage\nspec:\n  validationFailureAction: Enforce\n  rules:\n    - name: require-encrypted-storage-class\n      match:\n        any:\n          - resources:\n              kinds:\n                - PersistentVolumeClaim\n      validate:\n        message: "Only encrypted storage classes are allowed"\n        pattern:\n          spec:\n            storageClassName: "*encrypted*"\n'})}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"5-restrict-access-modes",children:"5. Restrict Access Modes"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Issue:"})," ",(0,i.jsx)(s.code,{children:"ReadWriteMany"})," (RWX) volumes allow multiple pods to access the same data, potentially across namespaces.",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(s.strong,{children:"Fix:"})," Limit use of RWX volumes and audit their usage."]}),"\n",(0,i.jsx)(s.h3,{id:"admission-policy-to-block-rwx-in-production",children:"Admission Policy to Block RWX in Production"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-yaml",children:'apiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: restrict-rwx-volumes\nspec:\n  validationFailureAction: Enforce\n  rules:\n    - name: block-rwx-production\n      match:\n        any:\n          - resources:\n              kinds:\n                - PersistentVolumeClaim\n              namespaces:\n                - production\n      validate:\n        message: "ReadWriteMany access mode is not allowed in production"\n        pattern:\n          spec:\n            accessModes:\n              - "!ReadWriteMany"\n'})}),"\n",(0,i.jsx)(s.h3,{id:"audit-existing-rwx-volumes",children:"Audit Existing RWX Volumes"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:'kubectl get pv -o json | jq -r \'.items[] | \n  select(.spec.accessModes[] | contains("ReadWriteMany")) | \n  "\\(.metadata.name) - \\(.spec.claimRef.namespace)/\\(.spec.claimRef.name)"\'\n'})}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"6-implement-volume-snapshots-securely",children:"6. Implement Volume Snapshots Securely"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Issue:"})," Volume snapshots may contain sensitive data and be accessible to unauthorized users.",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(s.strong,{children:"Fix:"})," Restrict snapshot creation and access through RBAC."]}),"\n",(0,i.jsx)(s.h3,{id:"restrict-snapshot-permissions",children:"Restrict Snapshot Permissions"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-yaml",children:'apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: snapshot-reader\n  namespace: production\nrules:\n  - apiGroups: ["snapshot.storage.k8s.io"]\n    resources: ["volumesnapshots"]\n    verbs: ["get", "list"]\n    # create/delete restricted to admins\n'})}),"\n",(0,i.jsx)(s.h3,{id:"secure-snapshot-class",children:"Secure Snapshot Class"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-yaml",children:'apiVersion: snapshot.storage.k8s.io/v1\nkind: VolumeSnapshotClass\nmetadata:\n  name: secure-snapshots\ndriver: ebs.csi.aws.com\ndeletionPolicy: Delete\nparameters:\n  encrypted: "true"\n'})}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"7-monitor-and-audit-volume-access",children:"7. Monitor and Audit Volume Access"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Issue:"})," Unauthorized volume access may go undetected.",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(s.strong,{children:"Fix:"})," Enable audit logging for PV/PVC operations."]}),"\n",(0,i.jsx)(s.h3,{id:"api-server-audit-policy",children:"API Server Audit Policy"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-yaml",children:'apiVersion: audit.k8s.io/v1\nkind: Policy\nrules:\n  - level: RequestResponse\n    resources:\n      - group: ""\n        resources: ["persistentvolumes", "persistentvolumeclaims"]\n    verbs: ["create", "delete", "patch", "update"]\n'})}),"\n",(0,i.jsx)(s.h3,{id:"falco-rules-for-volume-access",children:"Falco Rules for Volume Access"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-yaml",children:'- rule: Sensitive Volume Mount\n  desc: Detect mounts of volumes containing sensitive data\n  condition: >\n    container.volume_mounts contains "/secrets" or\n    container.volume_mounts contains "/credentials"\n  output: >\n    Sensitive volume mounted (pod=%k8s.pod.name \n    ns=%k8s.ns.name mount=%container.volume_mounts)\n  priority: WARNING\n'})}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"security-checklist",children:"Security Checklist"}),"\n",(0,i.jsxs)(s.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(s.li,{className:"task-list-item",children:[(0,i.jsx)(s.input,{type:"checkbox",disabled:!0})," ","Storage classes use ",(0,i.jsx)(s.code,{children:"Delete"})," reclaim policy"]}),"\n",(0,i.jsxs)(s.li,{className:"task-list-item",children:[(0,i.jsx)(s.input,{type:"checkbox",disabled:!0})," ","Volume encryption enabled for all storage classes"]}),"\n",(0,i.jsxs)(s.li,{className:"task-list-item",children:[(0,i.jsx)(s.input,{type:"checkbox",disabled:!0})," ","PVC creation restricted through RBAC"]}),"\n",(0,i.jsxs)(s.li,{className:"task-list-item",children:[(0,i.jsx)(s.input,{type:"checkbox",disabled:!0})," ","Resource quotas limit storage per namespace"]}),"\n",(0,i.jsxs)(s.li,{className:"task-list-item",children:[(0,i.jsx)(s.input,{type:"checkbox",disabled:!0})," ","RWX access mode restricted in production"]}),"\n",(0,i.jsxs)(s.li,{className:"task-list-item",children:[(0,i.jsx)(s.input,{type:"checkbox",disabled:!0})," ","Volume snapshot permissions controlled"]}),"\n",(0,i.jsxs)(s.li,{className:"task-list-item",children:[(0,i.jsx)(s.input,{type:"checkbox",disabled:!0})," ","Audit logging enabled for PV/PVC operations"]}),"\n",(0,i.jsxs)(s.li,{className:"task-list-item",children:[(0,i.jsx)(s.input,{type:"checkbox",disabled:!0})," ","Regular review of released/available PVs"]}),"\n",(0,i.jsxs)(s.li,{className:"task-list-item",children:[(0,i.jsx)(s.input,{type:"checkbox",disabled:!0})," ","Process to scrub retained volumes before reuse"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"references",children:"References"}),"\n",(0,i.jsx)(s.p,{children:"This article is based on information from the following official sources:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"https://kubernetes.io/docs/concepts/storage/persistent-volumes/",children:"Persistent Volumes"})," - Kubernetes Documentation"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"https://kubernetes.io/docs/concepts/storage/storage-classes/",children:"Storage Classes"})," - Kubernetes Documentation"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"https://kubernetes.io/docs/concepts/storage/volume-snapshots/",children:"Volume Snapshots"})," - Kubernetes Documentation"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"https://kubernetes.io/docs/concepts/policy/resource-quotas/",children:"Resource Quotas"})," - Kubernetes Documentation"]}),"\n"]})]})}function u(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,s,n){n.d(s,{R:()=>a,x:()=>o});var t=n(6540);const i={},r=t.createContext(i);function a(e){const s=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);