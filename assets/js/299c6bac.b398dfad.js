"use strict";(globalThis.webpackChunkk_8_s_security=globalThis.webpackChunkk_8_s_security||[]).push([[7644],{4732(e,n,s){s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>c,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"best-practices/cluster-setup-and-hardening/configuration-validation/kubectl-kubesec","title":"kubectl-kubesec","description":"kubectl-kubesec is a kubectl plugin that scans Kubernetes resources using kubesec.io to identify security risks and provide hardening recommendations.","source":"@site/docs/best-practices/cluster-setup-and-hardening/configuration-validation/kubectl-kubesec.md","sourceDirName":"best-practices/cluster-setup-and-hardening/configuration-validation","slug":"/best-practices/cluster-setup-and-hardening/configuration-validation/kubectl-kubesec","permalink":"/kubernetes-security/best-practices/cluster-setup-and-hardening/configuration-validation/kubectl-kubesec","draft":false,"unlisted":false,"editUrl":"https://github.com/geek-kb/k8s_security/edit/main/docs/best-practices/cluster-setup-and-hardening/configuration-validation/kubectl-kubesec.md","tags":[{"inline":true,"label":"tool","permalink":"/kubernetes-security/tags/tool"},{"inline":true,"label":"configuration-validation","permalink":"/kubernetes-security/tags/configuration-validation"},{"inline":true,"label":"security-scanning","permalink":"/kubernetes-security/tags/security-scanning"},{"inline":true,"label":"CKS","permalink":"/kubernetes-security/tags/cks"}],"version":"current","lastUpdatedBy":"Itai Ganot","lastUpdatedAt":1771236448000,"sidebarPosition":10,"frontMatter":{"sidebar_position":10,"title":"kubectl-kubesec","description":"kubectl-kubesec is a kubectl plugin that scans Kubernetes resources using kubesec.io to identify security risks and provide hardening recommendations.","keywords":["kubernetes security tool","kubectl-kubesec","kubesec","security scanning","kubernetes hardening","pod security","configuration validation","security score","CKS"],"tags":["tool","configuration-validation","security-scanning","CKS"],"related":["/kubernetes-security/best-practices/cluster-setup-and-hardening/configuration-validation/kube-score/","/kubernetes-security/best-practices/cluster-setup-and-hardening/pod-security/pod-security-standards/","/kubernetes-security/best-practices/cluster-setup-and-hardening/configuration-validation/kube-linter/"]},"sidebar":"default","previous":{"title":"kube-scan","permalink":"/kubernetes-security/best-practices/cluster-setup-and-hardening/configuration-validation/kube-scan"},"next":{"title":"Steampipe for Kubernetes","permalink":"/kubernetes-security/best-practices/cluster-setup-and-hardening/configuration-validation/steampipe"}}');var t=s(4848),r=s(8453);const c={sidebar_position:10,title:"kubectl-kubesec",description:"kubectl-kubesec is a kubectl plugin that scans Kubernetes resources using kubesec.io to identify security risks and provide hardening recommendations.",keywords:["kubernetes security tool","kubectl-kubesec","kubesec","security scanning","kubernetes hardening","pod security","configuration validation","security score","CKS"],tags:["tool","configuration-validation","security-scanning","CKS"],related:["/kubernetes-security/best-practices/cluster-setup-and-hardening/configuration-validation/kube-score/","/kubernetes-security/best-practices/cluster-setup-and-hardening/pod-security/pod-security-standards/","/kubernetes-security/best-practices/cluster-setup-and-hardening/configuration-validation/kube-linter/"]},a="kubectl-kubesec",l={},o=[{value:"How It Works",id:"how-it-works",level:2},{value:"Installation",id:"installation",level:2},{value:"Using krew",id:"using-krew",level:3},{value:"Manual Installation",id:"manual-installation",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Scan a Running Pod",id:"scan-a-running-pod",level:3},{value:"Scan a Deployment",id:"scan-a-deployment",level:3},{value:"Scan a DaemonSet",id:"scan-a-daemonset",level:3},{value:"Scan a StatefulSet",id:"scan-a-statefulset",level:3},{value:"Scan from YAML File",id:"scan-from-yaml-file",level:3},{value:"Scan Multiple Resources",id:"scan-multiple-resources",level:3},{value:"Example Output",id:"example-output",level:2},{value:"Understanding Scores",id:"understanding-scores",level:2},{value:"Score Components",id:"score-components",level:3},{value:"Score Interpretation",id:"score-interpretation",level:3},{value:"Common Findings and Remediations",id:"common-findings-and-remediations",level:2},{value:"Critical: Privileged Container",id:"critical-privileged-container",level:3},{value:"Critical: No Security Context",id:"critical-no-security-context",level:3},{value:"Advise: AppArmor Profile",id:"advise-apparmor-profile",level:3},{value:"Advise: Resource Limits",id:"advise-resource-limits",level:3},{value:"CI/CD Integration",id:"cicd-integration",level:2},{value:"GitHub Actions",id:"github-actions",level:3},{value:"Shell Script for CI",id:"shell-script-for-ci",level:3},{value:"Local kubesec Server",id:"local-kubesec-server",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"kubectl-kubesec",children:"kubectl-kubesec"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"kubectl-kubesec"})," is a kubectl plugin that integrates kubesec.io security scanning directly into your Kubernetes workflow. It analyzes Kubernetes resources (Pods, Deployments, StatefulSets, DaemonSets) for security risks and provides actionable recommendations for hardening."]}),"\n",(0,t.jsx)(n.p,{children:"kubesec assigns a security score based on detected issues, making it easy to track security improvements over time."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,t.jsx)(n.p,{children:"kubectl-kubesec sends Kubernetes resource definitions to the kubesec.io API (or a local kubesec instance) for analysis. The scanner evaluates:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Security context configurations"}),"\n",(0,t.jsx)(n.li,{children:"Container capabilities"}),"\n",(0,t.jsx)(n.li,{children:"Volume mount security"}),"\n",(0,t.jsx)(n.li,{children:"Resource limits and requests"}),"\n",(0,t.jsx)(n.li,{children:"Network configuration"}),"\n",(0,t.jsx)(n.li,{children:"Service account settings"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Each finding affects the overall security score, with critical issues resulting in score deductions."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,t.jsx)(n.h3,{id:"using-krew",children:"Using krew"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl krew install kubesec-scan\n"})}),"\n",(0,t.jsx)(n.h3,{id:"manual-installation",children:"Manual Installation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Download the plugin\ncurl -LO https://github.com/controlplaneio/kubectl-kubesec/releases/download/v2.0.0/kubectl-kubesec_linux_amd64.tar.gz\n\n# Extract and install\ntar xzf kubectl-kubesec_linux_amd64.tar.gz\nchmod +x kubectl-kubesec\nsudo mv kubectl-kubesec /usr/local/bin/\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,t.jsx)(n.h3,{id:"scan-a-running-pod",children:"Scan a Running Pod"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl kubesec-scan pod my-pod -n production\n"})}),"\n",(0,t.jsx)(n.h3,{id:"scan-a-deployment",children:"Scan a Deployment"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl kubesec-scan deployment my-deployment\n"})}),"\n",(0,t.jsx)(n.h3,{id:"scan-a-daemonset",children:"Scan a DaemonSet"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl kubesec-scan daemonset my-daemonset -n kube-system\n"})}),"\n",(0,t.jsx)(n.h3,{id:"scan-a-statefulset",children:"Scan a StatefulSet"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl kubesec-scan statefulset my-statefulset\n"})}),"\n",(0,t.jsx)(n.h3,{id:"scan-from-yaml-file",children:"Scan from YAML File"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl kubesec-scan -f deployment.yaml\n"})}),"\n",(0,t.jsx)(n.h3,{id:"scan-multiple-resources",children:"Scan Multiple Resources"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl kubesec-scan -f ./manifests/\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"example-output",children:"Example Output"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'[\n  {\n    "object": "Pod/my-app.production",\n    "valid": true,\n    "fileName": "STDIN",\n    "message": "",\n    "score": 3,\n    "scoring": {\n      "critical": [\n        {\n          "id": "Privileged",\n          "selector": "containers[] .securityContext .privileged == true",\n          "reason": "Privileged containers share namespaces with the host system",\n          "points": -30\n        }\n      ],\n      "passed": [\n        {\n          "id": "ReadOnlyRootFilesystem",\n          "selector": "containers[] .securityContext .readOnlyRootFilesystem == true",\n          "reason": "Immutable container filesystems prevent runtime modifications",\n          "points": 1\n        },\n        {\n          "id": "RunAsNonRoot",\n          "selector": "containers[] .securityContext .runAsNonRoot == true",\n          "reason": "Force the container to run as a non-root user",\n          "points": 1\n        }\n      ],\n      "advise": [\n        {\n          "id": "ApparmorAny",\n          "selector": ".metadata .annotations .\\"container.apparmor.security.beta.kubernetes.io/nginx\\"",\n          "reason": "AppArmor prevents execution of arbitrary code",\n          "points": 3\n        }\n      ]\n    }\n  }\n]\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"understanding-scores",children:"Understanding Scores"}),"\n",(0,t.jsx)(n.h3,{id:"score-components",children:"Score Components"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Category"}),(0,t.jsx)(n.th,{children:"Description"}),(0,t.jsx)(n.th,{children:"Points"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Critical"}),(0,t.jsx)(n.td,{children:"Severe security issues"}),(0,t.jsx)(n.td,{children:"-30 to -10"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Passed"}),(0,t.jsx)(n.td,{children:"Security best practices followed"}),(0,t.jsx)(n.td,{children:"+1 to +5"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Advise"}),(0,t.jsx)(n.td,{children:"Recommended improvements"}),(0,t.jsx)(n.td,{children:"+1 to +3 (if implemented)"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"score-interpretation",children:"Score Interpretation"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Score"}),(0,t.jsx)(n.th,{children:"Assessment"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"< 0"}),(0,t.jsx)(n.td,{children:"Critical issues present, requires immediate attention"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"0-3"}),(0,t.jsx)(n.td,{children:"Poor security posture, significant hardening needed"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"4-6"}),(0,t.jsx)(n.td,{children:"Moderate security, some improvements recommended"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"7+"}),(0,t.jsx)(n.td,{children:"Good security posture"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"common-findings-and-remediations",children:"Common Findings and Remediations"}),"\n",(0,t.jsx)(n.h3,{id:"critical-privileged-container",children:"Critical: Privileged Container"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Container runs in privileged mode"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Remediation:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"spec:\n  containers:\n    - name: my-container\n      securityContext:\n        privileged: false\n"})}),"\n",(0,t.jsx)(n.h3,{id:"critical-no-security-context",children:"Critical: No Security Context"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," Container lacks security context"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Remediation:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"spec:\n  containers:\n    - name: my-container\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 1000\n        readOnlyRootFilesystem: true\n        allowPrivilegeEscalation: false\n        capabilities:\n          drop:\n            - ALL\n"})}),"\n",(0,t.jsx)(n.h3,{id:"advise-apparmor-profile",children:"Advise: AppArmor Profile"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," No AppArmor profile specified"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Remediation:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"metadata:\n  annotations:\n    container.apparmor.security.beta.kubernetes.io/my-container: runtime/default\n"})}),"\n",(0,t.jsx)(n.h3,{id:"advise-resource-limits",children:"Advise: Resource Limits"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," No resource limits specified"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Remediation:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'spec:\n  containers:\n    - name: my-container\n      resources:\n        limits:\n          cpu: "1"\n          memory: "512Mi"\n        requests:\n          cpu: "100m"\n          memory: "128Mi"\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"cicd-integration",children:"CI/CD Integration"}),"\n",(0,t.jsx)(n.h3,{id:"github-actions",children:"GitHub Actions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'name: Security Scan\non: [push, pull_request]\n\njobs:\n  kubesec:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Run kubesec scanner\n        uses: controlplaneio/kubesec-action@v2\n        with:\n          input: deployment.yaml\n          \n      - name: Check score\n        run: |\n          score=$(cat kubesec-results.json | jq \'.[0].score\')\n          if [ "$score" -lt 0 ]; then\n            echo "Security score too low: $score"\n            exit 1\n          fi\n'})}),"\n",(0,t.jsx)(n.h3,{id:"shell-script-for-ci",children:"Shell Script for CI"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\nset -e\n\n# Scan all YAML files\nfor file in $(find ./kubernetes -name "*.yaml"); do\n  echo "Scanning $file..."\n  result=$(kubectl kubesec-scan -f "$file" 2>/dev/null || true)\n  score=$(echo "$result" | jq \'.[0].score // 0\')\n  \n  if [ "$score" -lt 0 ]; then\n    echo "FAILED: $file has critical security issues (score: $score)"\n    echo "$result" | jq \'.[0].scoring.critical\'\n    exit 1\n  fi\ndone\n\necho "All resources passed security scan"\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"local-kubesec-server",children:"Local kubesec Server"}),"\n",(0,t.jsx)(n.p,{children:"For air-gapped environments or to avoid sending manifests externally:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Run kubesec locally\ndocker run -d -p 8080:8080 kubesec/kubesec http 8080\n\n# Use local server\nkubectl kubesec-scan pod my-pod --server http://localhost:8080\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Set minimum scores:"})," Require a minimum security score for production deployments."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Integrate into CI/CD:"})," Block merges or deployments that fail security scans."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Address critical issues first:"})," Focus on negative-scoring findings before optimizing."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use local scanning:"})," Run a local kubesec server for sensitive environments."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Combine with other tools:"})," Use alongside kube-linter and kube-score for comprehensive validation."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsx)(n.p,{children:"This article is based on information from the following official sources:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/controlplaneio/kubectl-kubesec",children:"kubectl-kubesec GitHub Repository"})," - Control Plane"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://kubesec.io/",children:"kubesec.io"})," - kubesec.io"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/security/pod-security-standards/",children:"Pod Security Standards"})," - Kubernetes Documentation"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>c,x:()=>a});var i=s(6540);const t={},r=i.createContext(t);function c(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);